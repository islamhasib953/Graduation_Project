Ø·ÙŠØ¨ Ø§ÙˆÙ„Ø§ Ø¹Ø§ÙŠØ² Ø§ØªØ§ÙƒØ¯ Ù…Ù† Ø­Ø§Ø¬Ø©ÙˆÙ‡Ù‰ Ø§Ù† Ù„ÙƒÙ„ Ø·ÙÙ„ Ø§Ù„ notifivation  Ø§Ù„Ø®Ø§ØµØ© Ø¨ÙŠÙ‡ Ù„Ø§Ù† ÙƒÙ„ ÙŠÙˆØ²Ø± Ù…Ù…ÙƒÙ† ÙŠÙƒÙˆÙ† Ù„ÙŠÙ‡ Ø§ÙƒØ«Ø± Ù…Ù† Ø·ÙÙ„ 
Ø«Ø§Ù†ÙŠØ§ Ø¹Ø§ÙŠØ² ÙØ§ÙŠÙ„ Ø±ÙŠØ¯Ù…Ù‰ ÙŠØ´Ø±Ø­ Ø§Ù„Ù…ÙˆØ´ÙˆØ¹ ÙˆØ²Ø§Ù‰ Ø§Ø³ØªØ®Ø¯Ù… Ø­Ø§Ø¬Ø© Ø²Ù‰ ÙƒØ¯Ù‡
Ø§Ø®ÙŠØ±Ø§ Ù‡Ø¨ØªØ¹Ù„Ùƒ ÙƒÙ„ Ø§Ù„ÙÙ„Ø§ÙŠÙ„Ø§Øª Ø§Ù„Ù„Ù‰ Ø¹Ù†Ø¯Ù‰ ÙˆØ¹Ø¯Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¹Ù„Ø´Ø§Ù† Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„ notifiation Ø¹Ù„Ø´Ø§Ù† ÙŠØªÙ… ÙˆØ§Ø¨Ø¹Øª Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ ÙƒÙ„Ù‡Ø§ ØªØ§Ù†Ù‰ Ù…Ù† ØºÙŠØ± Ù…Ø§ ØªØ¨ÙˆØ¸ Ø§Ù‰ Ø­Ø§Ø¬Ø© ÙÙ‰ Ø§Ù„Ù„ÙˆØ¬ÙŠÙƒ Ø¹Ù„Ø´Ø§Ù† Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ ÙƒÙ„Ù‡Ø§ Ø³Ù„ÙŠÙ…Ù‡ ÙˆØ´ØºØ§Ù„Ø©

Ù„Ùˆ Ø¹Ø§ÙŠØ²Ø© Ù†Ø¶ÙŠÙ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù„Ø­Ø§Ø¬Ø§Øª ØªØ§Ù†ÙŠØ© (Ø²ÙŠ Ø¥Ù† Ø§Ù„Ø¯ÙƒØªÙˆØ± ÙŠØ¶ÙŠÙ Ù…Ù„Ø§Ø­Ø¸Ø© ÙÙŠ Ø§Ù„Ø³Ø¬Ù„ Ø§Ù„Ø·Ø¨ÙŠ Ø¨ØªØ§Ø¹ Ø§Ù„Ø·ÙÙ„ØŒ Ø£Ùˆ Ø£ÙŠ Ø­Ø¯Ø« ØªØ§Ù†ÙŠ)ØŒ
app file
const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const bodyParser = require("body-parser");
const cookieParser = require("cookie-parser");
const dotenv = require("dotenv");
const cors = require("cors");
const morgan = require("morgan");
const limitReq = require("express-rate-limit");
const mongoSanitize = require("express-mongo-sanitize");
const xssClean = require("xss-clean");
const hpp = require("hpp");

const appError = require("./utils/appError");
const httpStatusText = require("./utils/httpStatusText");
const MQTTService = require("./services/mqtt.service");
const connectDB = require("./config/db.config");

// Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù€ Routes
const medicineRoutes = require("./routes/medicine.route");
const usersRoutes = require("./routes/users.route");
const childRoutes = require("./routes/child.route");
const historyRoutes = require("./routes/history.route");
const memoryRoutes = require("./routes/memory.route");
const vaccinationRoutes = require("./routes/vaccination.route");
const growthRoutes = require("./routes/growth.route");
const doctorRoutes = require("./routes/doctor.route");
const sensorDataRoutes = require("./routes/sensorData.route");
const predictionRoutes = require("./routes/predict.route");

// Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ©
dotenv.config({ path: "./.env" });
const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: "*", // Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ¯ Ù†Ø·Ø§Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ§Ø¬
    methods: ["GET", "POST"],
  },
});

// Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Express
app.use("/uploads", express.static("uploads"));
app.use(express.json());
app.use(bodyParser.json());
app.use(cookieParser());

// Middlewares
// Ø£. Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø£Ù…Ø§Ù†
app.use(cors());
app.use(mongoSanitize());
app.use(xssClean());
app.use(hpp());

// Ø¨. Rate Limiting
const limiter = limitReq({
  max: 200,
  windowMs: 1000 * 60 * 60,
  message: "Too many requests, try again after one hour",
});
app.use(limiter);

// Ø¬. Morgan Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
app.use(morgan("combined"));

// Ø¯. Express Messages
app.use(async (req, res, next) => {
  res.locals.messages = require("express-messages")(req, res);
  next();
});

// Ø¥Ø¹Ø¯Ø§Ø¯ MongoDB
connectDB();

// Ø¥Ø¹Ø¯Ø§Ø¯ MQTT
const mqttService = new MQTTService(io);
mqttService.connect();

// Ø§Ù„Ù€ Routes
app.use("/api/users", usersRoutes);
app.use("/api/medicines", medicineRoutes);
app.use("/api/children", childRoutes);
app.use("/api/history", historyRoutes);
app.use("/api/memory", memoryRoutes);
app.use("/api/vaccinations", vaccinationRoutes);
app.use("/api/growth", growthRoutes);
app.use("/api/doctors", doctorRoutes);
app.use("/api/sensor-data", sensorDataRoutes);
app.use("/api/predictions", predictionRoutes);

// Middleware Ù„Ù„Ù€ Routes Ø§Ù„ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©
app.all("*", (req, res) => {
  return res.status(404).json({
    status: httpStatusText.ERROR,
    data: { message: "This resource not found" },
  });
});

// Global Error Handler
app.use((error, req, res, next) => {
  res.status(error.statusCode || 500).json({
    status: error.statusText || httpStatusText.ERROR,
    message: error.message,
    code: error.statusCode || 500,
    data: null,
  });
});

module.exports = { app, server };
*********************************************
index file


const mongoose = require("mongoose");
const { app, server } = require("./app");

process.on("uncaughtException", (err) => {
  console.error("â›” " + err.name, err.message, err.stack);
  process.exit(1);
});

const port = process.env.PORT || 8000;

server.listen(port, () => console.log(`âœ… app listening on port ${port}`));

process.on("unhandledRejection", (err) => {
  console.error("ğŸš¨ " + err.name, err.message);
  server.close(() => process.exit(1));
});
*******************************
child reoutes
const express = require("express");
const { validationResult } = require("express-validator");
const router = express.Router();

const verifyToken = require("../middlewares/virifyToken");
const checkOwnership = require("../middlewares/Ownership");
const childController = require("../controllers/child.controller");
const validationschema = require("../middlewares/validationschema");



router
  .route("/")
  // .get(verifyToken, checkOwnership, childController.getAllChildren)
  .post(
    verifyToken,
    checkOwnership,
    validationschema.validateChild,
    childController.createChild
  )
  .get(
    verifyToken,
    checkOwnership,
    validationschema.validateChild,
    childController.getChildrenForUser
  );

router
  .route("/:childId")
  .get(verifyToken, checkOwnership, childController.getSingleChild)
  .patch(
    verifyToken,
    checkOwnership,
    validationschema.validateChild,
    childController.updateChild
  )
  .delete(verifyToken, checkOwnership, childController.deleteChild);

module.exports = router;

**************************
doctor routes
const express = require("express");
const router = express.Router();

const verifyToken = require("../middlewares/virifyToken");
const allowedTo = require("../middlewares/allowedTo");
const userRoles = require("../utils/userRoles");
const doctorController = require("../controllers/doctor.controller");

// Routes Ù„Ù„Ø¯ÙƒØªÙˆØ± Ù†ÙØ³Ù‡ (Profile, Logout) - Ù…Ø´ Ù…Ø­ØªØ§Ø¬ childId
router
  .route("/profile")
  .get(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
    doctorController.getDoctorProfile
  )
  .patch(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
    doctorController.updateDoctorProfile
  )
  .delete(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
    doctorController.deleteDoctorProfile
  );

router.post(
  "/logout",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
  doctorController.logoutDoctor
);

// Route Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£ÙŠØ§Ù… ÙˆØ§Ù„Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© (Ø¬Ø¯ÙŠØ¯)
router.patch(
  "/availability",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
  doctorController.updateAvailability
);

// Route Ù„Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© (Ø«Ø§Ø¨Øª)
router.get(
  "/appointments/upcoming",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
  doctorController.getUpcomingAppointments
);

// Route Ù„Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¬Ù„ Ø§Ù„Ø·Ø¨ÙŠ ÙˆØ¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù…Ùˆ Ø¨ØªØ§Ø¹Ø© Ø§Ù„Ø·ÙÙ„ (Ø«Ø§Ø¨ØªØŒ Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ Ø§Ù„Ù€ Routes Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©)
router.post(
  "/child/records",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
  doctorController.getChildRecords
);

// Route Ù„ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¬Ø² (ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ appointmentId)
router.patch(
  "/appointments/:appointmentId/status",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
  doctorController.updateAppointmentStatus
);

// Route Ù„Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø¨ØªØ§Ø¹Ø© Ø§Ù„ÙŠÙˆØ²Ø± Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path
router.get(
  "/appointments/user/:childId",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.PATIENT),
  doctorController.getUserAppointments
);

// Route Ù„Ø¬Ù„Ø¨ Ø§Ù„Ø¯ÙƒØ§ØªØ±Ø© Ø§Ù„Ù…ÙØ¶Ù„ÙŠÙ† Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path (Ø«Ø§Ø¨ØªØŒ Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ /:childId)
router.get(
  "/favorites/:childId",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.PATIENT),
  doctorController.getFavoriteDoctors
);

// Route Ù„Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„Ø¯ÙƒØ§ØªØ±Ø© Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path (Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ)
router.get(
  "/:childId",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR, userRoles.PATIENT),
  doctorController.getAllDoctors
);

// Routes Ù„ØªÙØ§ØµÙŠÙ„ Ø¯ÙƒØªÙˆØ± Ù…Ø¹ÙŠÙ† Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path (Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ)
router
  .route("/:childId/:doctorId")
  .get(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.DOCTOR, userRoles.PATIENT),
    doctorController.getSingleDoctor
  );

// Route Ù„Ø­Ø¬Ø² Ù…ÙˆØ¹Ø¯ Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path
router.post(
  "/:childId/:doctorId/book",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.PATIENT),
  doctorController.bookAppointment
);

// Routes Ù„Ø¥Ø¶Ø§ÙØ© ÙˆØ¥Ø²Ø§Ù„Ø© Ø¯ÙƒØªÙˆØ± Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø© Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path
router
  .route("/:childId/:doctorId/favorite")
  .post(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    doctorController.addToFavorite
  )
  .delete(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    doctorController.removeFromFavorite
  );

// Routes Ù„ØªØ¹Ø¯ÙŠÙ„ ÙˆØ¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø² Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path
router
  .route("/appointments/:childId/:appointmentId")
  .patch(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    doctorController.rescheduleAppointment
  )
  .delete(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    doctorController.deleteAppointment
  );

module.exports = router;
**************************************
user routes
const express = require("express");
const usersController = require("../controllers/users.controller");
const verifyToken = require("../middlewares/virifyToken");
const allowedTo = require("../middlewares/allowedTo");
const userRoles = require("../utils/userRoles");
const checkOwnership = require("../middlewares/Ownership");
const {
  validateRegister,
  validateLogin,
  validateUpdateUser,
} = require("../middlewares/validationschema");

const multer = require("multer");
const appError = require("../utils/appError");
const fs = require("fs");
const path = require("path");

const diskStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(__dirname, "..", "Uploads");
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const ext = file.mimetype.split("/")[1];
    cb(null, `user-${Date.now()}.${ext}`);
  },
});

const fileFilter = (req, file, cb) => {
  file.mimetype.startsWith("image")
    ? cb(null, true)
    : cb(appError.create("The file must be an image", 400), false);
};

const upload = multer({ storage: diskStorage, fileFilter });

const router = express.Router();

router
  .route("/")
  .get(verifyToken, allowedTo(userRoles.ADMIN), usersController.getAllUsers);

router
  .route("/register")
  .post(
    upload.single("avatar"),
    validateRegister,
    usersController.registerUser
  );

router.route("/login").post(validateLogin, usersController.loginUser);

router
  .route("/profile")
  .get(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    usersController.getUserProfile
  )
  .patch(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    usersController.updateUserProfile
  )
  .delete(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    usersController.deleteUserProfile
  );

router.post(
  "/logout",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.PATIENT),
  usersController.logoutUser
);

// router
//   .route("/:userId")
//   .get(verifyToken, checkOwnership, usersController.getUserById)
//   .patch(
//     verifyToken,
//     checkOwnership,
//     validateUpdateUser,
//     usersController.updateUser
//   )
//   .delete(verifyToken, checkOwnership, usersController.deleteUser);

module.exports = router;
********************************************
child model
const mongoose = require("mongoose");

const ChildSchema = new mongoose.Schema(
  {
    name: { type: String, required: [true, "Name is required"], trim: true },
    gender: {
      type: String,
      enum: ["Boy", "Girl"],
      required: [true, "Gender is required"],
    },
    birthDate: { type: Date, required: [true, "Birth date is required"] },
    heightAtBirth: { type: Number, min: [0, "Height must be positive"] },
    weightAtBirth: { type: Number, min: [0, "Weight must be positive"] },
    headCircumferenceAtBirth: {
      type: Number,
      min: [0, "Head circumference must be positive"],
    },
    bloodType: {
      type: String,
      match: [/^(A|B|AB|O)[+-]$/, "Invalid blood type"],
    },
    parentId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    deviceId: { type: String, required: false, unique: true }, // Ø­Ù‚Ù„ Ø¬Ø¯ÙŠØ¯ Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø³Ø§Ø¹Ø©
    photo: {
      type: String,
      default: "Uploads/vaccination.jpg",
      validate: {
        validator: function (value) {
          return /\.(jpg|jpeg|png|gif)$/i.test(value);
        },
        message: "Image must be a valid image file",
      },
    },
    favorite: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Doctor",
        required: false,
      },
    ], // Ø­Ù‚Ù„ Ø¬Ø¯ÙŠØ¯ Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¯ÙƒØ§ØªØ±Ø© Ø§Ù„Ù…ÙØ¶Ù„Ø© Ù„ÙƒÙ„ Ø·ÙÙ„
  },
  { timestamps: true }
);

module.exports = mongoose.model("Child", ChildSchema);
***************************************************
const mongoose = require("mongoose");
const validator = require("validator");
const userRoles = require("../utils/userRoles");

const doctorSchema = new mongoose.Schema({
  firstName: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  lastName: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  gender: {
    type: String,
    enum: ["Male", "Female"],
    required: true,
  },
  phone: {
    type: String,
    required: true,
    unique: true,
    validate: {
      validator: function (value) {
        return /^01[0-2,5]\d{8}$/.test(value);
      },
      message: "Invalid Egyptian phone number",
    },
  },
  address: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    minlength: 2,
    maxlength: 255,
    validate: [validator.isEmail, "Invalid Email"],
  },
  password: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  token: {
    type: String,
    required: false,
  },
  role: {
    type: String,
    enum: [userRoles.DOCTOR], // ØªØ­Ø¯ÙŠØ¯ Ø¥Ù† Ø§Ù„Ù€ role Ù‡Ù†Ø§ Ù„Ù„Ø¯ÙƒØªÙˆØ± Ø¨Ø³
    default: userRoles.DOCTOR, // Ø§Ù„ØªØ£ÙƒØ¯ Ø¥Ù† Ø§Ù„Ù€ default Ù…Ø´ Ù…Ø¹Ù„Ù‘Ù‚
    required: true, // Ø¬Ø¹Ù„Ù†Ø§Ù‡ Ø¥Ø¬Ø¨Ø§Ø±ÙŠ
  },
  fcmToken: { type: String, default: null }, // Ø­Ù‚Ù„ Ø¬Ø¯ÙŠØ¯
  avatar: {
    type: String,
    default: "uploads/doctor.jpg",
  },
  specialise: {
    type: String,
    required: false,
    minlength: 2,
    maxlength: 255,
    trim: true,
  },
  about: {
    type: String,
    required: false,
    minlength: 2,
    maxlength: 500,
    trim: true,
  },
  rate: {
    type: Number,
    required: false,
    min: 0,
    max: 5,
    default: 0,
  },
  availableDays: [
    {
      type: String,
      required: false,
      trim: true,
    },
  ],
  availableTimes: [
    {
      type: String,
      required: false,
      trim: true,
    },
  ],
  created_at: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model("Doctor", doctorSchema);
**********************************************************************

user model
const mongoose = require("mongoose");
const validator = require("validator");
const userRoles = require("../utils/userRoles");

const userSchema = new mongoose.Schema({
  firstName: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  lastName: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  gender: {
    type: String,
    enum: ["Male", "Female"],
    required: true,
  },
  phone: {
    type: String,
    required: true,
    unique: true,
    validate: {
      validator: function (value) {
        return /^01[0-2,5]\d{8}$/.test(value);
      },
      message: "Invalid Egyptian phone number",
    },
  },
  address: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    minlength: 2,
    maxlength: 255,
    validate: [validator.isEmail, "Invalid Email"],
  },
  password: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  token: {
    type: String,
    required: false,
  },
  role: {
    type: String,
    enum: [userRoles.ADMIN, userRoles.PATIENT],
    default: userRoles.PATIENT,
    required: true,
  },
  fcmToken: { type: String, default: null }, // Ø­Ù‚Ù„ Ø¬Ø¯ÙŠØ¯
  avatar: {
    type: String,
    default: "uploads/profile.jpg",
  },
  created_at: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model("User", userSchema);
************************************************
child cotroller
const Child = require("../models/child.model");
const User = require("../models/user.model");
const asyncWrapper = require("../middlewares/asyncWrapper");
const httpStatusText = require("../utils/httpStatusText");
const appError = require("../utils/appError");
const VaccineInfo = require("../models/vaccineInfo.model");
const UserVaccination = require("../models/UserVaccination.model");

// âœ… Create new child and assign all existing vaccinations
const createChild = asyncWrapper(async (req, res, next) => {
  const {
    name,
    gender,
    photo,
    birthDate,
    bloodType,
    heightAtBirth,
    weightAtBirth,
    headCircumferenceAtBirth,
  } = req.body;

  const parentId = req.user.id; // Get parentId from logged-in user

  if (
    !name ||
    !gender ||
    !birthDate ||
    !bloodType ||
    !heightAtBirth ||
    !weightAtBirth ||
    !headCircumferenceAtBirth
  ) {
    return next(
      appError.create("All fields are required", 400, httpStatusText.FAIL)
    );
  }

  const parent = await User.findById(parentId);
  if (!parent) {
    return next(
      appError.create("Parent does not exist", 404, httpStatusText.FAIL)
    );
  }

  const childPhoto = photo || "Uploads/child.jpg";

  // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·ÙÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯
  const newChild = new Child({
    name,
    gender,
    photo: childPhoto,
    parentId,
    birthDate,
    bloodType,
    heightAtBirth,
    weightAtBirth,
    headCircumferenceAtBirth,
  });

  await newChild.save();

  // âœ… Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ·Ø¹ÙŠÙ…Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  const allVaccines = await VaccineInfo.find();

  // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ ØªØ·Ø¹ÙŠÙ…Ø§ØªØŒ Ø£Ø¶ÙÙ‡Ø§ Ù„Ù„Ø·ÙÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯
  if (allVaccines.length > 0) {
    const vaccinationsToCreate = allVaccines.map((vaccine) => {
      const dueDate = new Date(birthDate);
      dueDate.setMonth(dueDate.getMonth() + vaccine.originalSchedule);

      return {
        childId: newChild._id,
        vaccineInfoId: vaccine._id,
        dueDate,
      };
    });

    await UserVaccination.insertMany(vaccinationsToCreate);
  }

  res.status(201).json({
    status: httpStatusText.SUCCESS,
    message: "Child created successfully and assigned vaccinations.",
    data: {
      child: newChild,
      parentPhone: parent.phone,
    },
  });
});

// âœ… Get all children for admin
const getAllChildren = asyncWrapper(async (req, res) => {
  const children = await Child.find({}, "_id name birthDate photo");
  res.json({
    status: httpStatusText.SUCCESS,
    data: children.map((child) => ({
      id: child._id,
      name: child.name,
      birthDate: child.birthDate,
      photo: child.photo,
    })),
  });
});

// âœ… Get all children for a specific user (logged-in user)
const getChildrenForUser = asyncWrapper(async (req, res, next) => {
  const userId = req.user.id;
  const children = await Child.find({ parentId: userId })
    .select(
      "_id name gender birthDate heightAtBirth weightAtBirth headCircumferenceAtBirth bloodType photo parentId"
    )
    .populate("parentId", "phone");

  if (!children.length) {
    return next(
      appError.create(
        "No children found for this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  res.json({
    status: httpStatusText.SUCCESS,
    data: children.map((child) => ({
      _id: child._id,
      name: child.name,
      gender: child.gender,
      birthDate: child.birthDate,
      heightAtBirth: child.heightAtBirth,
      weightAtBirth: child.weightAtBirth,
      headCircumferenceAtBirth: child.headCircumferenceAtBirth,
      bloodType: child.bloodType,
      photo: child.photo,
      parentPhone: child.parentId?.phone || null,
      parentId: child.parentId?._id || null,
    })),
  });
});

// âœ… Get single child with all details
const getSingleChild = asyncWrapper(async (req, res, next) => {
  const { childId } = req.params;

  const child = await Child.findById(childId)
    .select(
      "_id name gender birthDate heightAtBirth weightAtBirth headCircumferenceAtBirth bloodType photo parentId"
    )
    .populate("parentId", "phone");

  if (!child) {
    return next(appError.create("Child not found", 404, httpStatusText.FAIL));
  }

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      _id: child._id,
      name: child.name,
      gender: child.gender,
      birthDate: child.birthDate,
      heightAtBirth: child.heightAtBirth,
      weightAtBirth: child.weightAtBirth,
      headCircumferenceAtBirth: child.headCircumferenceAtBirth,
      bloodType: child.bloodType,
      photo: child.photo,
      parentPhone: child.parentId?.phone || null,
    },
  });
});

// âœ… Update a child
const updateChild = asyncWrapper(async (req, res, next) => {
  const { childId } = req.params;
  const {
    name,
    gender,
    birthDate,
    bloodType,
    heightAtBirth,
    weightAtBirth,
    headCircumferenceAtBirth,
    photo,
  } = req.body;

  const updatedChild = await Child.findByIdAndUpdate(
    childId,
    {
      name,
      gender,
      birthDate,
      bloodType,
      heightAtBirth,
      weightAtBirth,
      headCircumferenceAtBirth,
      photo,
    },
    { new: true }
  );

  if (!updatedChild) {
    return next(appError.create("Child not found", 404, httpStatusText.FAIL));
  }

  res.json({
    status: httpStatusText.SUCCESS,
    data: { child: updatedChild },
  });
});

// âœ… Delete a child
const deleteChild = asyncWrapper(async (req, res, next) => {
  const deletedChild = await Child.findByIdAndDelete(req.params.childId);

  if (!deletedChild) {
    return next(appError.create("Child not found", 404, httpStatusText.FAIL));
  }

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Child deleted successfully",
  });
});

module.exports = {
  createChild,
  getAllChildren,
  getChildrenForUser,
  getSingleChild,
  updateChild,
  deleteChild,
};

********************************
doctor controller
const Doctor = require("../models/doctor.model");
const User = require("../models/user.model");
const Appointment = require("../models/appointment.model");
const Child = require("../models/child.model");
const History = require("../models/history.model");
const Growth = require("../models/growth.model");
const asyncWrapper = require("../middlewares/asyncWrapper");
const httpStatusText = require("../utils/httpStatusText");
const appError = require("../utils/appError");
const userRoles = require("../utils/userRoles");
const moment = require("moment");
const mongoose = require("mongoose");

// âœ… Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„Ø¯ÙƒØ§ØªØ±Ø© (Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path)
const getAllDoctors = asyncWrapper(async (req, res, next) => {
  const { childId } = req.params;
  const userId = req.user.id;

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  const doctors = await Doctor.find().select(
    "firstName lastName phone availableTimes availableDays created_at address avatar specialise about rate"
  );

  if (!doctors.length) {
    return next(appError.create("No doctors found", 404, httpStatusText.FAIL));
  }

  const currentDay = moment().format("dddd");
  const today = moment().startOf("day").toDate();

  const doctorsWithStatus = await Promise.all(
    doctors.map(async (doctor) => {
      const hasAvailableDays =
        doctor.availableDays && doctor.availableDays.length > 0;
      const hasAvailableTimes =
        doctor.availableTimes && doctor.availableTimes.length > 0;

      if (!hasAvailableDays || !hasAvailableTimes) {
        return {
          _id: doctor._id,
          firstName: doctor.firstName,
          lastName: doctor.lastName,
          phone: doctor.phone,
          availableTimes: doctor.availableTimes,
          availableDays: doctor.availableDays,
          created_at: doctor.created_at,
          address: doctor.address,
          avatar: doctor.avatar,
          specialise: doctor.specialise,
          about: doctor.about,
          rate: doctor.rate,
          status: "Closed",
          isFavorite: child.favorite.includes(doctor._id),
        };
      }

      const isDayAvailable = doctor.availableDays.includes(currentDay);
      if (!isDayAvailable) {
        return {
          _id: doctor._id,
          firstName: doctor.firstName,
          lastName: doctor.lastName,
          phone: doctor.phone,
          availableTimes: doctor.availableTimes,
          availableDays: doctor.availableDays,
          created_at: doctor.created_at,
          address: doctor.address,
          avatar: doctor.avatar,
          specialise: doctor.specialise,
          about: doctor.about,
          rate: doctor.rate,
          status: "Closed",
          isFavorite: child.favorite.includes(doctor._id),
        };
      }

      const bookedAppointments = await Appointment.find({
        doctorId: doctor._id,
        date: today,
      }).select("time");

      const bookedTimes = bookedAppointments.map(
        (appointment) => appointment.time
      );

      const hasAvailableTimeToday = doctor.availableTimes.some(
        (time) => !bookedTimes.includes(time)
      );

      const status = hasAvailableTimeToday ? "Open" : "Closed";

      return {
        _id: doctor._id,
        firstName: doctor.firstName,
        lastName: doctor.lastName,
        phone: doctor.phone,
        availableTimes: doctor.availableTimes,
        availableDays: doctor.availableDays,
        created_at: doctor.created_at,
        address: doctor.address,
        avatar: doctor.avatar,
        specialise: doctor.specialise,
        about: doctor.about,
        rate: doctor.rate,
        status,
        isFavorite: child.favorite.includes(doctor._id),
      };
    })
  );

  res.json({
    status: httpStatusText.SUCCESS,
    data: doctorsWithStatus,
  });
});

// âœ… Ø¹Ø±Ø¶ ØªÙØ§ØµÙŠÙ„ Ø¯ÙƒØªÙˆØ± Ù…Ø¹ÙŠÙ† (Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path)
const getSingleDoctor = asyncWrapper(async (req, res, next) => {
  const { doctorId, childId } = req.params;
  const userId = req.user.id;

  if (
    !req.user ||
    ![userRoles.PATIENT, userRoles.DOCTOR].includes(req.user.role)
  ) {
    return next(
      appError.create(
        "Unauthorized: Only patients or doctors can view doctor details",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (req.user.role !== userRoles.DOCTOR) {
    const child = await Child.findOne({ _id: childId, parentId: userId });
    if (!child) {
      return next(
        appError.create(
          "Child not found or not associated with this user",
          404,
          httpStatusText.FAIL
        )
      );
    }
  }

  const doctor = await Doctor.findById(doctorId).select(
    "firstName lastName phone availableTimes availableDays created_at address avatar specialise about rate"
  );

  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  const currentDay = moment().format("dddd");
  const today = moment().startOf("day").toDate();

  const hasAvailableDays =
    doctor.availableDays && doctor.availableDays.length > 0;
  const hasAvailableTimes =
    doctor.availableTimes && doctor.availableTimes.length > 0;

  let status = "Closed";

  if (hasAvailableDays && hasAvailableTimes) {
    const isDayAvailable = doctor.availableDays.includes(currentDay);
    if (isDayAvailable) {
      const bookedAppointments = await Appointment.find({
        doctorId: doctor._id,
        date: today,
      }).select("time");

      const bookedTimes = bookedAppointments.map(
        (appointment) => appointment.time
      );

      const hasAvailableTimeToday = doctor.availableTimes.some(
        (time) => !bookedTimes.includes(time)
      );

      if (hasAvailableTimeToday) {
        status = "Open";
      }
    }
  }

  const bookedAppointments = await Appointment.find({
    doctorId,
    childId,
  }).select("date time");

  const child = await Child.findById(childId);

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      _id: doctor._id,
      firstName: doctor.firstName,
      lastName: doctor.lastName,
      phone: doctor.phone,
      availableTimes: doctor.availableTimes,
      availableDays: doctor.availableDays,
      created_at: doctor.created_at,
      address: doctor.address,
      avatar: doctor.avatar,
      specialise: doctor.specialise,
      about: doctor.about,
      rate: doctor.rate,
      status,
      bookedAppointments: bookedAppointments.map((appointment) => ({
        date: appointment.date,
        time: appointment.time,
      })),
      isFavorite: child ? child.favorite.includes(doctor._id) : false,
    },
  });
});


// âœ… Ø­Ø¬Ø² Ù…ÙˆØ¹Ø¯ Ù…Ø¹ Ø¯ÙƒØªÙˆØ± (Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path)
const bookAppointment = asyncWrapper(async (req, res, next) => {
  const { doctorId, childId } = req.params;
  const { date, time, visitType } = req.body;
  const userId = req.user.id;

  if (!date || !time || !visitType) {
    return next(
      appError.create(
        "Date, time, and visit type are required",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  const appointmentDate = moment(date);
  if (appointmentDate.isBefore(moment(), "day")) {
    return next(
      appError.create(
        "Cannot book an appointment in the past",
        400,
        httpStatusText.FAIL
      )
    );
  }

  if (!/^(1[0-2]|0?[1-9]):([0-5][0-9]) (AM|PM)$/i.test(time)) {
    return next(
      appError.create(
        "Time must be in the format HH:MM AM/PM (e.g., 9:00 AM)",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId);
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  const hasAvailableDays =
    doctor.availableDays && doctor.availableDays.length > 0;
  const hasAvailableTimes =
    doctor.availableTimes && doctor.availableTimes.length > 0;
  if (!hasAvailableDays || !hasAvailableTimes) {
    return next(
      appError.create(
        "Doctor is not available for booking",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const requestedDay = moment(date).format("dddd");
  const normalizedTime = time.trim().toUpperCase();
  const isDayAvailable = doctor.availableDays.includes(requestedDay);
  const isTimeAvailable = doctor.availableTimes.includes(normalizedTime);

  if (!isDayAvailable || !isTimeAvailable) {
    return next(
      appError.create(
        "Doctor is not available at this date or time",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const existingAppointment = await Appointment.findOne({
    doctorId,
    date: moment(date).startOf("day").toDate(),
    time: normalizedTime,
  });

  if (existingAppointment) {
    return next(
      appError.create(
        "This exact appointment (date and time) is already booked",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const newAppointment = new Appointment({
    userId,
    doctorId,
    childId,
    date: moment(date).startOf("day").toDate(),
    time: normalizedTime,
    visitType,
  });

  await newAppointment.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Appointment booked successfully",
    data: {
      appointmentId: newAppointment._id,
      doctorId: doctor._id,
      childId: newAppointment.childId,
      date: moment(newAppointment.date).format("YYYY-MM-DD"),
      time: newAppointment.time,
      visitType,
    },
  });
});

// âœ… Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø¨ØªØ§Ø¹Ø© Ø§Ù„ÙŠÙˆØ²Ø± (Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path)
const getUserAppointments = asyncWrapper(async (req, res, next) => {
  const { childId } = req.params;
  const userId = req.user.id;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can view their appointments",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  const appointments = await Appointment.find({ userId, childId })
    .populate("doctorId", "firstName lastName avatar address")
    .populate("childId", "name")
    .select("doctorId childId date time visitType status created_at");

  if (!appointments.length) {
    return next(
      appError.create("No appointments found", 404, httpStatusText.FAIL)
    );
  }

  const sortedAppointments = appointments.sort(
    (a, b) => new Date(a.date) - new Date(b.date)
  );

  const groupedAppointments = sortedAppointments.reduce((acc, appointment) => {
    const date = new Date(appointment.date);
    const monthYear = `${date.toLocaleString("default", {
      month: "short",
    })} ${date.getFullYear()}`;

    if (!acc[monthYear]) {
      acc[monthYear] = [];
    }

    acc[monthYear].push({
      appointmentId: appointment._id,
      childId: appointment.childId._id,
      childName: appointment.childId.name,
      doctorId: appointment.doctorId._id,
      doctorName: `${appointment.doctorId.firstName} ${appointment.doctorId.lastName}`,
      doctorAvatar: appointment.doctorId.avatar,
      doctorAddress: appointment.doctorId.address,
      date: appointment.date,
      time: appointment.time,
      visitType: appointment.visitType,
      status: appointment.status,
    });

    return acc;
  }, {});

  res.json({
    status: httpStatusText.SUCCESS,
    data: groupedAppointments,
  });
});

// âœ… ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¬Ø² (Accept Ø£Ùˆ Close)
const updateAppointmentStatus = asyncWrapper(async (req, res, next) => {
  const { appointmentId } = req.params;
  const { status } = req.body;
  const doctorId = req.user.id;

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can update appointment status",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (!status || !["Accepted", "Closed"].includes(status)) {
    return next(
      appError.create(
        "Status must be either 'Accepted' or 'Closed'",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const appointment = await Appointment.findById(appointmentId);

  if (!appointment) {
    return next(
      appError.create("Appointment not found", 404, httpStatusText.FAIL)
    );
  }

  if (appointment.doctorId.toString() !== doctorId.toString()) {
    return next(
      appError.create(
        "You are not authorized to update this appointment",
        403,
        httpStatusText.FAIL
      )
    );
  }

  appointment.status = status;
  await appointment.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Appointment status updated successfully",
    data: {
      appointmentId: appointment._id,
      status: appointment.status,
    },
  });
});

// âœ… Ø¬Ù„Ø¨ Ø§Ù„Ø¯ÙƒØ§ØªØ±Ø© Ø§Ù„Ù…ÙØ¶Ù„ÙŠÙ† Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path
const getFavoriteDoctors = asyncWrapper(async (req, res, next) => {
  const { childId } = req.params;
  const userId = req.user.id;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can view favorite doctors",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  const favoriteDoctorIds = child.favorite;
  if (!favoriteDoctorIds || favoriteDoctorIds.length === 0) {
    return next(
      appError.create("No favorite doctors found", 404, httpStatusText.FAIL)
    );
  }

  const doctors = await Doctor.find({
    _id: { $in: favoriteDoctorIds },
  }).select(
    "firstName lastName phone availableTimes availableDays created_at address avatar specialise about rate"
  );

  if (!doctors.length) {
    return next(
      appError.create("No favorite doctors found", 404, httpStatusText.FAIL)
    );
  }

  const currentDay = moment().format("dddd");
  const today = moment().startOf("day").toDate();

  const doctorsWithStatus = await Promise.all(
    doctors.map(async (doctor) => {
      const hasAvailableDays =
        doctor.availableDays && doctor.availableDays.length > 0;
      const hasAvailableTimes =
        doctor.availableTimes && doctor.availableTimes.length > 0;

      if (!hasAvailableDays || !hasAvailableTimes) {
        return {
          _id: doctor._id,
          firstName: doctor.firstName,
          lastName: doctor.lastName,
          phone: doctor.phone,
          availableTimes: doctor.availableTimes,
          availableDays: doctor.availableDays,
          created_at: doctor.created_at,
          address: doctor.address,
          avatar: doctor.avatar,
          specialise: doctor.specialise,
          about: doctor.about,
          rate: doctor.rate,
          status: "Closed",
          isFavorite: true,
        };
      }

      const isDayAvailable = doctor.availableDays.includes(currentDay);
      if (!isDayAvailable) {
        return {
          _id: doctor._id,
          firstName: doctor.firstName,
          lastName: doctor.lastName,
          phone: doctor.phone,
          availableTimes: doctor.availableTimes,
          availableDays: doctor.availableDays,
          created_at: doctor.created_at,
          address: doctor.address,
          avatar: doctor.avatar,
          specialise: doctor.specialise,
          about: doctor.about,
          rate: doctor.rate,
          status: "Closed",
          isFavorite: true,
        };
      }

      const bookedAppointments = await Appointment.find({
        doctorId: doctor._id,
        date: today,
      }).select("time");

      const bookedTimes = bookedAppointments.map(
        (appointment) => appointment.time
      );

      const hasAvailableTimeToday = doctor.availableTimes.some(
        (time) => !bookedTimes.includes(time)
      );

      const status = hasAvailableTimeToday ? "Open" : "Closed";

      return {
        _id: doctor._id,
        firstName: doctor.firstName,
        lastName: doctor.lastName,
        phone: doctor.phone,
        availableTimes: doctor.availableTimes,
        availableDays: doctor.availableDays,
        created_at: doctor.created_at,
        address: doctor.address,
        avatar: doctor.avatar,
        specialise: doctor.specialise,
        about: doctor.about,
        rate: doctor.rate,
        status,
        isFavorite: true,
      };
    })
  );

  res.json({
    status: httpStatusText.SUCCESS,
    data: doctorsWithStatus,
  });
});

// âœ… ØªØ¹Ø¯ÙŠÙ„ Ù…ÙˆØ¹Ø¯ Ø§Ù„Ø­Ø¬Ø² (Reschedule) (Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path)
const rescheduleAppointment = asyncWrapper(async (req, res, next) => {
  const { appointmentId, childId } = req.params;
  const { date, time } = req.body;
  const userId = req.user.id;

  if (!date || !time) {
    return next(
      appError.create("Date and time are required", 400, httpStatusText.FAIL)
    );
  }

  const newDate = moment(date);
  if (newDate.isBefore(moment(), "day")) {
    return next(
      appError.create(
        "Cannot reschedule to a past date",
        400,
        httpStatusText.FAIL
      )
    );
  }

  if (!/^(1[0-2]|0?[1-9]):([0-5][0-9]) (AM|PM)$/i.test(time)) {
    return next(
      appError.create(
        "Time must be in the format HH:MM AM/PM (e.g., 9:00 AM)",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const appointment = await Appointment.findById(appointmentId);

  if (!appointment) {
    return next(
      appError.create("Appointment not found", 404, httpStatusText.FAIL)
    );
  }

  if (appointment.userId.toString() !== userId.toString()) {
    return next(
      appError.create(
        "You are not authorized to reschedule this appointment",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (appointment.childId.toString() !== childId) {
    return next(
      appError.create(
        "This appointment does not belong to the specified child",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (appointment.status === "Accepted") {
    return next(
      appError.create(
        "Cannot reschedule an accepted appointment. You can only cancel it.",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(appointment.doctorId);
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  const requestedDay = newDate.format("dddd");
  const isDayAvailable = doctor.availableDays.includes(requestedDay);
  const isTimeAvailable = doctor.availableTimes.includes(time);

  if (!isDayAvailable || !isTimeAvailable) {
    return next(
      appError.create(
        "Doctor is not available at this new date or time",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const existingAppointment = await Appointment.findOne({
    doctorId: appointment.doctorId,
    date: newDate.startOf("day").toDate(),
    time,
    _id: { $ne: appointmentId },
  });

  if (existingAppointment) {
    return next(
      appError.create(
        "This exact new time slot (date and time) is already booked",
        400,
        httpStatusText.FAIL
      )
    );
  }

  appointment.date = newDate.startOf("day").toDate();
  appointment.time = time;
  await appointment.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Appointment rescheduled successfully",
    data: {
      appointmentId: appointment._id,
      childId: appointment.childId,
      date: appointment.date,
      time: appointment.time,
    },
  });
});

// âœ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø² (Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path)
const deleteAppointment = asyncWrapper(async (req, res, next) => {
  const { appointmentId, childId } = req.params;
  const userId = req.user.id;

  const appointment = await Appointment.findById(appointmentId);

  if (!appointment) {
    return next(
      appError.create("Appointment not found", 404, httpStatusText.FAIL)
    );
  }

  if (appointment.userId.toString() !== userId.toString()) {
    return next(
      appError.create(
        "You are not authorized to delete this appointment",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (appointment.childId.toString() !== childId) {
    return next(
      appError.create(
        "This appointment does not belong to the specified child",
        403,
        httpStatusText.FAIL
      )
    );
  }

  await Appointment.deleteOne({ _id: appointmentId });

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Appointment deleted successfully",
  });
});


// âœ… Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© Ù„Ù„Ø¯ÙƒØªÙˆØ±
const getUpcomingAppointments = asyncWrapper(async (req, res, next) => {
  if (!req.user || !req.user.id) {
    return next(
      appError.create(
        "Unauthorized: User ID not found in token",
        401,
        httpStatusText.FAIL
      )
    );
  }

  const doctorId = req.user.id;

  if (!mongoose.Types.ObjectId.isValid(doctorId)) {
    return next(
      appError.create("Invalid Doctor ID in token", 400, httpStatusText.FAIL)
    );
  }

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can view their upcoming appointments",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId).select(
    "firstName lastName avatar"
  );
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  const today = moment().startOf("day").toDate();

  // Ø§Ø³ØªØ®Ø¯Ø§Ù… Aggregation Pipeline Ù„Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
  const appointments = await Appointment.aggregate([
    // Ø§Ù„Ø´Ø±Ø· Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ: doctorIdØŒ Ø§Ù„ØªØ§Ø±ÙŠØ® Ù…Ù† Ø§Ù„ÙŠÙˆÙ… ÙˆÙ…Ø§ Ø¨Ø¹Ø¯ØŒ ÙˆØ§Ø³ØªØ¨Ø¹Ø§Ø¯ Closed
    {
      $match: {
        doctorId: new mongoose.Types.ObjectId(doctorId),
        date: { $gte: today },
        status: { $ne: "Closed" },
      },
    },
    // Populate userId Ùˆ childId
    {
      $lookup: {
        from: "users",
        localField: "userId",
        foreignField: "_id",
        as: "userId",
        pipeline: [
          {
            $project: {
              firstName: 1,
              lastName: 1,
              address: 1,
            },
          },
        ],
      },
    },
    {
      $unwind: "$userId",
    },
    {
      $lookup: {
        from: "children",
        localField: "childId",
        foreignField: "_id",
        as: "childId",
      },
    },
    {
      $unwind: "$childId",
    },
    // ØªØ­ÙˆÙŠÙ„ time Ù…Ù† ØµÙŠØºØ© 12 Ø³Ø§Ø¹Ø© (Ù…Ø«Ù„ "8:00 PM") Ø¥Ù„Ù‰ 24 Ø³Ø§Ø¹Ø© (Ù…Ø«Ù„ "20:00")
    {
      $addFields: {
        trimmedTime: { $trim: { input: "$time" } }, // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§ÙØ§Øª
      },
    },
    {
      $addFields: {
        timeParts: {
          $regexMatch: {
            input: "$trimmedTime",
            regex: "^(\\d{1,2}):(\\d{2})\\s*(AM|PM)$",
            options: "i",
          },
        },
      },
    },
    {
      $addFields: {
        hour: { $toInt: { $arrayElemAt: ["$timeParts.captures", 0] } },
        minute: { $arrayElemAt: ["$timeParts.captures", 1] },
        period: { $arrayElemAt: ["$timeParts.captures", 2] },
      },
    },
    {
      $addFields: {
        hour24: {
          $cond: {
            if: { $eq: [{ $toUpper: "$period" }, "PM"] },
            then: {
              $cond: {
                if: { $eq: ["$hour", 12] },
                then: 12,
                else: { $add: ["$hour", 12] },
              },
            },
            else: {
              $cond: {
                if: { $eq: ["$hour", 12] },
                then: 0,
                else: "$hour",
              },
            },
          },
        },
      },
    },
    {
      $addFields: {
        time24: {
          $concat: [
            { $cond: { if: { $lt: ["$hour24", 10] }, then: "0", else: "" } },
            { $toString: "$hour24" },
            ":",
            { $cond: { if: { $lt: ["$minute", 10] }, then: "0", else: "" } },
            "$minute",
          ],
        },
      },
    },
    // Ø¥Ù†Ø´Ø§Ø¡ Ø­Ù‚Ù„ Ù…Ø¤Ù‚Øª Ù„ØªØ­ÙˆÙŠÙ„ date Ùˆ time Ø¥Ù„Ù‰ ØªØ§Ø±ÙŠØ® ÙƒØ§Ù…Ù„ Ù„Ù„Ù€ Accepted ÙÙ‚Ø·
    {
      $addFields: {
        appointmentDateTime: {
          $cond: {
            if: { $eq: ["$status", "Accepted"] },
            then: {
              $dateFromString: {
                dateString: {
                  $concat: [
                    { $dateToString: { format: "%Y-%m-%d", date: "$date" } },
                    "T",
                    "$time24",
                  ],
                },
                format: "%Y-%m-%dT%H:%M",
              },
            },
            else: null, // Ù„Ù„Ù€ PendingØŒ Ù„Ø§ Ø­Ø§Ø¬Ø© Ù„Ù€ appointmentDateTime
          },
        },
      },
    },
    // Ø¥Ø¶Ø§ÙØ© Ø­Ù‚Ù„ sortStatus Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ ØªØ±ØªÙŠØ¨ Pending Ùˆ Accepted
    {
      $addFields: {
        sortStatus: {
          $cond: {
            if: { $eq: ["$status", "Pending"] },
            then: 1,
            else: 2,
          },
        },
      },
    },
    // Ø¥Ø¶Ø§ÙØ© Ø­Ù‚Ù„ sortKey Ù„Ù„ØªØ±ØªÙŠØ¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ created_at Ù„Ù€ Pending Ùˆ appointmentDateTime Ù„Ù€ Accepted
    {
      $addFields: {
        sortKey: {
          $cond: {
            if: { $eq: ["$status", "Pending"] },
            then: "$created_at",
            else: "$appointmentDateTime",
          },
        },
      },
    },
    // Ø§Ù„ØªØ±ØªÙŠØ¨
    {
      $sort: {
        sortStatus: 1, // Pending (1) Ù‚Ø¨Ù„ Accepted (2)
        sortKey: 1, // Pending Ø­Ø³Ø¨ created_at, Accepted Ø­Ø³Ø¨ appointmentDateTime
      },
    },
    // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
    {
      $project: {
        userId: {
          firstName: "$userId.firstName",
          lastName: "$userId.lastName",
          address: "$userId.address",
        },
        childId: {
          name: "$childId.name",
        },
        date: 1,
        time: 1,
        visitType: 1,
        status: 1,
        created_at: 1,
        _id: 1,
      },
    },
  ]);

  const upcomingCount = appointments.length;

  const upcomingAppointments = appointments.map((appointment) => {
    const appointmentData = {
      appointmentId: appointment._id,
      userName: `${appointment.userId.firstName} ${appointment.userId.lastName}`,
      childName: appointment.childId.name,
      place: appointment.visitType,
      date: moment(appointment.date).format("YYYY-MM-DD"),
      time: appointment.time,
      status:
        appointment.status === "Accepted"
          ? "ACCEPTED"
          : appointment.status === "Closed"
          ? "REFUSED"
          : "PENDING",
      created_at: moment(appointment.created_at).format("YYYY-MM-DD HH:mm:ss"),
    };

    // Ø¥Ø¶Ø§ÙØ© address Ù„Ùˆ visitType Ù‡Ùˆ In-Person
    if (appointment.visitType === "In-Person") {
      appointmentData.address = appointment.userId.address;
    }

    return appointmentData;
  });

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      doctor: {
        name: `${doctor.firstName} ${doctor.lastName}`,
        avatar: doctor.avatar,
        upcomingCount: upcomingCount,
      },
      appointments: upcomingAppointments,
    },
  });
});

// âœ… Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¬Ù„ Ø§Ù„Ø·Ø¨ÙŠ ÙˆØ¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù…Ùˆ Ø¨ØªØ§Ø¹Ø© Ø§Ù„Ø·ÙÙ„ (Ø¨ÙŠØ§Ø®Ø¯ childId Ù…Ù† Ø§Ù„Ù€ Body)
const getChildRecords = asyncWrapper(async (req, res, next) => {
  const { childId } = req.body;
  const doctorId = req.user.id;

  if (!req.user || !req.user.id) {
    return next(
      appError.create(
        "Unauthorized: User ID not found in token",
        401,
        httpStatusText.FAIL
      )
    );
  }

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can access child records",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (!mongoose.Types.ObjectId.isValid(doctorId)) {
    return next(
      appError.create("Invalid Doctor ID in token", 400, httpStatusText.FAIL)
    );
  }

  if (!childId) {
    return next(
      appError.create(
        "Child ID is required in the body",
        400,
        httpStatusText.FAIL
      )
    );
  }

  if (!mongoose.Types.ObjectId.isValid(childId)) {
    return next(appError.create("Invalid Child ID", 400, httpStatusText.FAIL));
  }

  const child = await Child.findById(childId);
  if (!child) {
    return next(appError.create("Child not found", 404, httpStatusText.FAIL));
  }

  const medicalHistory = await History.find({ childId })
    .select(
      "diagnosis disease treatment notes date time doctorName notesImage createdAt updatedAt"
    )
    .sort({ date: -1 });

  const growthRecords = await Growth.find({ childId })
    .select(
      "weight height headCircumference date time notes notesImage ageInMonths createdAt updatedAt"
    )
    .sort({ date: -1 });

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      medicalHistory,
      growthRecords,
    },
  });
});

// âœ… Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙƒØªÙˆØ± (Profile)
const getDoctorProfile = asyncWrapper(async (req, res, next) => {
  const doctorId = req.user.id;

  if (!doctorId) {
    return next(
      appError.create("User ID not found in token", 401, httpStatusText.FAIL)
    );
  }

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can view their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId).select("-password -token");

  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      firstName: doctor.firstName,
      lastName: doctor.lastName,
      gender: doctor.gender,
      phone: doctor.phone,
      address: doctor.address,
      email: doctor.email,
      role: doctor.role,
      avatar: doctor.avatar,
      specialise: doctor.specialise,
      about: doctor.about,
      rate: doctor.rate,
      availableDays: doctor.availableDays,
      availableTimes: doctor.availableTimes,
      created_at: doctor.created_at,
    },
  });
});

// âœ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙƒØªÙˆØ± (Profile)
const updateDoctorProfile = asyncWrapper(async (req, res, next) => {
  const doctorId = req.user.id;
  const {
    firstName,
    lastName,
    email,
    phone,
    address,
    specialise,
    about,
    availableDays,
    availableTimes,
  } = req.body;

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can update their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId);

  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  if (firstName) doctor.firstName = firstName;
  if (lastName) doctor.lastName = lastName;
  if (email) doctor.email = email;
  if (phone) doctor.phone = phone;
  if (address) doctor.address = address;
  if (specialise) doctor.specialise = specialise;
  if (about) doctor.about = about;
  if (availableDays) doctor.availableDays = availableDays;
  if (availableTimes) doctor.availableTimes = availableTimes;

  await doctor.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Profile updated successfully",
    data: {
      firstName: doctor.firstName,
      lastName: doctor.lastName,
      gender: doctor.gender,
      phone: doctor.phone,
      address: doctor.address,
      email: doctor.email,
      role: doctor.role,
      avatar: doctor.avatar,
      specialise: doctor.specialise,
      about: doctor.about,
      rate: doctor.rate,
      availableDays: doctor.availableDays,
      availableTimes: doctor.availableTimes,
      created_at: doctor.created_at,
    },
  });
});

// âœ… Ø­Ø°Ù Ø§Ù„Ø£ÙƒÙˆÙ†Øª Ø¨ØªØ§Ø¹ Ø§Ù„Ø¯ÙƒØªÙˆØ± (Ù…Ø¹ Ù…Ø³Ø­ Ø§Ù„Ù€ Token)
const deleteDoctorProfile = asyncWrapper(async (req, res, next) => {
  const doctorId = req.user.id;
  const doctorEmail = req.user.email;

  console.log("Starting deleteDoctorProfile...");
  console.log("Doctor ID from token:", doctorId);
  console.log("Doctor Email from token:", doctorEmail);

  if (!doctorId) {
    console.log("No doctorId found in token");
    return next(
      appError.create("User ID not found in token", 401, httpStatusText.FAIL)
    );
  }

  if (!mongoose.Types.ObjectId.isValid(doctorId)) {
    console.log("Invalid doctorId format:", doctorId);
    return next(
      appError.create("Invalid Doctor ID in token", 400, httpStatusText.FAIL)
    );
  }

  if (req.user.role !== userRoles.DOCTOR) {
    console.log("User is not a doctor, role:", req.user.role);
    return next(
      appError.create(
        "Unauthorized: Only doctors can delete their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  console.log("Checking database connection...");
  const dbConnection = mongoose.connection;
  if (dbConnection.readyState !== 1) {
    console.log(
      "Database connection is not ready, state:",
      dbConnection.readyState
    );
    return next(
      appError.create("Database connection error", 500, httpStatusText.ERROR)
    );
  }
  console.log("Database connection is ready");

  const doctor = await Doctor.findById(doctorId);
  if (!doctor) {
    console.log("Doctor not found in database with ID:", doctorId);
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  console.log("Doctor found:", doctor.email);

  if (doctor.email !== doctorEmail) {
    console.log(
      "Email mismatch! Token email:",
      doctorEmail,
      "Doctor email:",
      doctor.email
    );
    return next(
      appError.create("Unauthorized: Email mismatch", 403, httpStatusText.FAIL)
    );
  }

  // Ø§Ø³ØªØ®Ø¯Ø§Ù… Transaction Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ù† ÙƒÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø¨ØªØªÙ… Ù…Ø¹ Ø¨Ø¹Ø¶
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    console.log("Clearing doctor token...");
    doctor.token = null;
    await doctor.save({ session });
    console.log("Token cleared successfully");

    console.log("Deleting appointments for doctorId:", doctorId);
    const appointmentDeleteResult = await Appointment.deleteMany(
      { doctorId },
      { session }
    );
    console.log(
      "Appointments deleted:",
      appointmentDeleteResult.deletedCount,
      "appointments"
    );

    console.log("Deleting doctor with ID:", doctorId);
    const deleteResult = await Doctor.deleteOne({ _id: doctorId }, { session });
    if (deleteResult.deletedCount === 0) {
      console.log("Failed to delete doctor: No doctor found during deletion");
      throw new Error("Failed to delete doctor account");
    }

    const doctorAfterDelete = await Doctor.findById(doctorId).session(session);
    if (doctorAfterDelete) {
      console.log("Doctor still exists after deletion:", doctorAfterDelete);
      throw new Error("Doctor account was not deleted from the database");
    }

    console.log("Doctor deleted successfully");

    console.log("Removing doctor from favorites...");
    const favoriteUpdateResult = await Child.updateMany(
      { favorite: doctorId },
      { $pull: { favorite: doctorId } },
      { session }
    );
    console.log(
      "Favorites updated, modified documents:",
      favoriteUpdateResult.modifiedCount
    );

    // Ø­Ø°Ù Ø§Ù„Ø¯ÙƒØªÙˆØ± Ù…Ù† Ø¬Ø¯ÙˆÙ„ User (Ù„Ùˆ Ù…ÙˆØ¬ÙˆØ¯)
    console.log("Deleting doctor from User collection...");
    const userDeleteResult = await User.deleteOne(
      { email: doctorEmail },
      { session }
    );
    console.log(
      "User deleted from User collection:",
      userDeleteResult.deletedCount,
      "users"
    );

    // Commit Ø§Ù„Ù€ Transaction
    await session.commitTransaction();
    console.log("Transaction committed successfully");

    res.json({
      status: httpStatusText.SUCCESS,
      message:
        "Doctor account, appointments, favorites, and user entry deleted successfully",
    });
  } catch (error) {
    // Rollback Ø§Ù„Ù€ Transaction Ù„Ùˆ Ø­ØµÙ„ Ø£ÙŠ Ø®Ø·Ø£
    await session.abortTransaction();
    console.log("Transaction aborted due to error:", error.message);
    return next(
      appError.create(
        error.message || "Failed to delete doctor account",
        500,
        httpStatusText.ERROR
      )
    );
  } finally {
    session.endSession();
  }
});

// âœ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù„Ù„Ø¯ÙƒØªÙˆØ±
const logoutDoctor = asyncWrapper(async (req, res, next) => {
  const doctorId = req.user.id;

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can logout",
        403,
        httpStatusText.FAIL
      )
    );
  }

  // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¯ÙƒØªÙˆØ±
  const doctor = await Doctor.findById(doctorId);
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  // Ø­Ø°Ù Ø§Ù„Ù€ token
  doctor.token = null;
  await doctor.save();

  // Ø§Ù„Ø±Ø¯ Ø¨Ù†Ø¬Ø§Ø­
  res.json({
    status: httpStatusText.SUCCESS,
    message: "Logged out successfully",
  });
});

// âœ… Ø¥Ø¶Ø§ÙØ© Ø¯ÙƒØªÙˆØ± Ù„Ù„Ù…ÙØ¶Ù„Ø© (Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path)
const addToFavorite = asyncWrapper(async (req, res, next) => {
  const { doctorId, childId } = req.params;
  const userId = req.user.id;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can add doctors to favorites",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId);
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  if (child.favorite.includes(doctorId)) {
    return next(
      appError.create("Doctor already in favorites", 400, httpStatusText.FAIL)
    );
  }

  child.favorite.push(doctorId);
  await child.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Doctor added to favorites successfully",
  });
});

// âœ… Ø¥Ø²Ø§Ù„Ø© Ø¯ÙƒØªÙˆØ± Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø© (Ù…Ø¹ childId ÙÙŠ Ø§Ù„Ù€ Path)
const removeFromFavorite = asyncWrapper(async (req, res, next) => {
  const { doctorId, childId } = req.params;
  const userId = req.user.id;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can remove doctors from favorites",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  if (!child.favorite.includes(doctorId)) {
    return next(
      appError.create("Doctor not found in favorites", 400, httpStatusText.FAIL)
    );
  }

  child.favorite = child.favorite.filter(
    (favId) => favId.toString() !== doctorId
  );
  await child.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Doctor removed from favorites successfully",
  });
});

// âœ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£ÙŠØ§Ù… ÙˆØ§Ù„Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ø¯ÙƒØªÙˆØ±
const updateAvailability = asyncWrapper(async (req, res, next) => {
  const doctorId = req.user.id;
  const { availableDays, availableTimes } = req.body;

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can update their availability",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (!availableDays && !availableTimes) {
    return next(
      appError.create(
        "At least one of availableDays or availableTimes is required",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId);
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£ÙŠØ§Ù…
  const validDays = [
    "Saturday",
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
  ];
  if (availableDays) {
    if (!Array.isArray(availableDays)) {
      return next(
        appError.create(
          "availableDays must be an array",
          400,
          httpStatusText.FAIL
        )
      );
    }
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù† Ù…ÙÙŠØ´ Ø£ÙŠØ§Ù… ÙØ§Ø¶ÙŠØ© Ø£Ùˆ Ù…ÙƒØ±Ø±Ø©
    const trimmedDays = availableDays.map((day) => day.trim());
    const uniqueDays = [...new Set(trimmedDays)];
    const invalidDays = uniqueDays.filter(
      (day) => !validDays.includes(day) || day === ""
    );
    if (invalidDays.length > 0) {
      return next(
        appError.create(
          `Invalid days: ${invalidDays.join(
            ", "
          )}. Days must be one of: ${validDays.join(", ")}`,
          400,
          httpStatusText.FAIL
        )
      );
    }
    doctor.availableDays = uniqueDays;
  }

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£ÙˆÙ‚Ø§Øª
  if (availableTimes) {
    if (!Array.isArray(availableTimes)) {
      return next(
        appError.create(
          "availableTimes must be an array",
          400,
          httpStatusText.FAIL
        )
      );
    }
    const timeFormatRegex = /^(1[0-2]|0?[1-9]):([0-5][0-9]) (AM|PM)$/i;
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù† Ù…ÙÙŠØ´ Ø£ÙˆÙ‚Ø§Øª ÙØ§Ø¶ÙŠØ© Ø£Ùˆ Ù…ÙƒØ±Ø±Ø©
    const trimmedTimes = availableTimes.map((time) =>
      time.trim().toUpperCase()
    );
    const uniqueTimes = [...new Set(trimmedTimes)];
    const invalidTimes = uniqueTimes.filter(
      (time) => !timeFormatRegex.test(time) || time === ""
    );
    if (invalidTimes.length > 0) {
      return next(
        appError.create(
          `Invalid times: ${invalidTimes.join(
            ", "
          )}. Times must be in the format HH:MM AM/PM (e.g., 9:00 AM)`,
          400,
          httpStatusText.FAIL
        )
      );
    }
    doctor.availableTimes = uniqueTimes;
  }

  await doctor.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Availability updated successfully",
    data: {
      availableDays: doctor.availableDays,
      availableTimes: doctor.availableTimes,
    },
  });
});

module.exports = {
  getAllDoctors,
  getSingleDoctor,
  bookAppointment,
  getUserAppointments,
  updateAppointmentStatus,
  rescheduleAppointment,
  deleteAppointment,
  getUpcomingAppointments,
  getDoctorProfile,//
  updateDoctorProfile,//
  deleteDoctorProfile,//
  logoutDoctor,//
  addToFavorite,
  removeFromFavorite,
  getFavoriteDoctors,
  getChildRecords,
  updateAvailability,
};
**********************************************
user controllers
const asyncWrapper = require("../middlewares/asyncWrapper");
const User = require("../models/user.model");
const Doctor = require("../models/doctor.model");
const httpStatusText = require("../utils/httpStatusText");
const appError = require("../utils/appError");
const bcrypt = require("bcryptjs");
const genrateJWT = require("../utils/genrate.JWT");
const userRoles = require("../utils/userRoles");
const mongoose = require("mongoose");

// Get all users
const getAllUsers = asyncWrapper(async (req, res) => {
  const users = await User.find({}, { __v: 0, password: false });
  res.json({ status: httpStatusText.SUCCESS, data: { users } });
});


// // Get a single user by ID
// const getUserById = asyncWrapper(async (req, res, next) => {
//   const { userId } = req.params;

//   const user = await User.findById(userId);

//   if (!user) {
//     return next(appError.create("User not found", 404, httpStatusText.FAIL));
//   }

//   res.json({ status: httpStatusText.SUCCESS, data: { user } });
// });

// âœ… Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙŠÙˆØ²Ø± (Profile)
const getUserProfile = asyncWrapper(async (req, res, next) => {
  const userId = req.user.id;

  if (!userId) {
    return next(
      appError.create("User ID not found in token", 401, httpStatusText.FAIL)
    );
  }

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can view their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const user = await User.findById(userId).select("-password -token");

  if (!user) {
    return next(appError.create("User not found", 404, httpStatusText.FAIL));
  }

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      firstName: user.firstName,
      lastName: user.lastName,
      gender: user.gender,
      phone: user.phone,
      address: user.address,
      email: user.email,
      role: user.role,
      avatar: user.avatar,
      favorite: user.favorite,
      created_at: user.created_at,
    },
  });
});

// âœ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙŠÙˆØ²Ø± (Profile)
const updateUserProfile = asyncWrapper(async (req, res, next) => {
  const userId = req.user.id;
  const { firstName, lastName, email, phone, address } = req.body;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can update their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const user = await User.findById(userId);

  if (!user) {
    return next(appError.create("User not found", 404, httpStatusText.FAIL));
  }

  if (firstName) user.firstName = firstName;
  if (lastName) user.lastName = lastName;
  if (email) user.email = email;
  if (phone) user.phone = phone;
  if (address) user.address = address;

  await user.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Profile updated successfully",
    data: {
      firstName: user.firstName,
      lastName: user.lastName,
      gender: user.gender,
      phone: user.phone,
      address: user.address,
      email: user.email,
      role: user.role,
      avatar: user.avatar,
      favorite: user.favorite,
      created_at: user.created_at,
    },
  });
});

// âœ… Ø­Ø°Ù Ø§Ù„Ø£ÙƒÙˆÙ†Øª Ø¨ØªØ§Ø¹ Ø§Ù„ÙŠÙˆØ²Ø± (Ù…Ø¹ Ù…Ø³Ø­ Ø§Ù„Ù€ Token)
const deleteUserProfile = asyncWrapper(async (req, res, next) => {
  const userId = req.user.id;
  const userEmail = req.user.email;

  if (!userId) {
    return next(
      appError.create("User ID not found in token", 401, httpStatusText.FAIL)
    );
  }

  if (!mongoose.Types.ObjectId.isValid(userId)) {
    return next(
      appError.create("Invalid User ID in token", 400, httpStatusText.FAIL)
    );
  }

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can delete their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const user = await User.findById(userId);
  if (!user) {
    return next(appError.create("User not found", 404, httpStatusText.FAIL));
  }

  if (user.email !== userEmail) {
    return next(
      appError.create("Unauthorized: Email mismatch", 403, httpStatusText.FAIL)
    );
  }

  // Ø§Ø³ØªØ®Ø¯Ø§Ù… Transaction Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ù† ÙƒÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø¨ØªØªÙ… Ù…Ø¹ Ø¨Ø¹Ø¶
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    user.token = null;
    await user.save({ session });

    const deleteResult = await User.deleteOne({ _id: userId }, { session });
    if (deleteResult.deletedCount === 0) {
      throw new Error("Failed to delete user account");
    }

    // Commit Ø§Ù„Ù€ Transaction
    await session.commitTransaction();

    res.json({
      status: httpStatusText.SUCCESS,
      message: "User account deleted successfully",
    });
  } catch (error) {
    // Rollback Ø§Ù„Ù€ Transaction Ù„Ùˆ Ø­ØµÙ„ Ø£ÙŠ Ø®Ø·Ø£
    await session.abortTransaction();
    return next(
      appError.create(
        error.message || "Failed to delete user account",
        500,
        httpStatusText.ERROR
      )
    );
  } finally {
    session.endSession();
  }
});

// âœ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù„Ù„ÙŠÙˆØ²Ø±
const logoutUser = asyncWrapper(async (req, res, next) => {
  const userId = req.user.id;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can logout",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const user = await User.findById(userId);
  if (!user) {
    return next(appError.create("User not found", 404, httpStatusText.FAIL));
  }

  user.token = null;
  await user.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Logged out successfully",
  });
});

// Register New User or Doctor
const registerUser = asyncWrapper(async (req, res, next) => {
  const {
    firstName,
    lastName,
    gender,
    phone,
    address,
    email,
    password,
    role,
    specialise,
    about,
    rate,
    availableDays,
    availableTimes,
  } = req.body;

  const oldUser = await User.findOne({ email });
  const oldDoctor = await Doctor.findOne({ email });
  if (oldUser || oldDoctor) {
    const error = appError.create(
      "Email already exists",
      400,
      httpStatusText.FAIL
    );
    return next(error);
  }

  const hashedPassword = await bcrypt.hash(password, 12);

  if (role === userRoles.DOCTOR) {
    const newDoctor = new Doctor({
      firstName,
      lastName,
      gender,
      phone,
      address,
      email,
      password: hashedPassword,
      role: userRoles.DOCTOR,
      specialise,
      about,
      rate,
      availableDays,
      availableTimes,
      avatar: req.file ? req.file.filename : "uploads/doctor.jpg",
    });

    const token = await genrateJWT(
      {
        email: newDoctor.email,
        id: newDoctor._id,
        role: newDoctor.role,
      },
      "7d"
    );
    newDoctor.token = token;

    await newDoctor.save();

    const doctorData = {
      _id: newDoctor._id,
      firstName: newDoctor.firstName,
      lastName: newDoctor.lastName,
      gender: newDoctor.gender,
      phone: newDoctor.phone,
      address: newDoctor.address,
      email: newDoctor.email,
      role: newDoctor.role,
      specialise: newDoctor.specialise,
      about: newDoctor.about,
      rate: newDoctor.rate,
      availableDays: newDoctor.availableDays,
      availableTimes: newDoctor.availableTimes,
      avatar: newDoctor.avatar,
      created_at: newDoctor.created_at,
      token: newDoctor.token,
    };

    res.status(201).json({
      status: httpStatusText.SUCCESS,
      message: "Doctor registered successfully",
      data: { user: doctorData },
    });
  } else {
    const newUser = new User({
      firstName,
      lastName,
      gender,
      phone,
      address,
      email,
      password: hashedPassword,
      role: userRoles.PATIENT,
      avatar: req.file ? req.file.filename : "uploads/profile.jpg",
    });

    const token = await genrateJWT(
      {
        email: newUser.email,
        id: newUser._id,
        role: newUser.role,
      },
      "7d"
    );
    newUser.token = token;

    await newUser.save();

    const userData = {
      _id: newUser._id,
      firstName: newUser.firstName,
      lastName: newUser.lastName,
      gender: newUser.gender,
      phone: newUser.phone,
      address: newUser.address,
      email: newUser.email,
      role: newUser.role,
      avatar: newUser.avatar,
      favorite: newUser.favorite,
      created_at: newUser.created_at,
      token: newUser.token,
    };

    res.status(201).json({
      status: httpStatusText.SUCCESS,
      message: "User registered successfully",
      data: { user: userData },
    });
  }
});

// Login User or Doctor
const loginUser = asyncWrapper(async (req, res, next) => {
  const { email, password } = req.body;
  if (!email || !password) {
    const error = appError.create(
      "Email and Password are required",
      400,
      httpStatusText.FAIL
    );
    return next(error);
  }

  let user = await User.findOne({ email });
  let role;

  if (user) {
    role = user.role;
  } else {
    user = await Doctor.findOne({ email });
    if (user) {
      role = user.role;
    }
  }

  if (!user) {
    const error = appError.create("User not found", 400, httpStatusText.FAIL);
    return next(error);
  }

  const isPasswordCorrect = await bcrypt.compare(password, user.password);
  if (isPasswordCorrect && user) {
    const token = await genrateJWT(
      {
        email: user.email,
        id: user._id,
        role: role,
      },
      "7d"
    );

    res.status(200).json({
      status: httpStatusText.SUCCESS,
      data: {
        token: token,
        role: role,
      },
    });
  } else {
    const error = appError.create(
      "Email or Password are incorrect",
      500,
      httpStatusText.ERROR
    );
    return next(error);
  }
});

// Update user details
// const updateUser = asyncWrapper(async (req, res, next) => {
//   const { userId } = req.params;
//   const { firstName, lastName, gender, phone, address, password, avatar } =
//     req.body;

//   let updateData = { firstName, lastName, gender, phone, address };

//   if (password) {
//     const hashedPassword = await bcrypt.hash(password, 12);
//     updateData.password = hashedPassword;
//   }

//   if (req.file) {
//     updateData.avatar = req.file.filename;
//   }

//   const updatedUser = await User.findByIdAndUpdate(userId, updateData, {
//     new: true,
//   });

//   if (!updatedUser) {
//     return next(appError.create("User not found", 404, httpStatusText.FAIL));
//   }

//   res.json({ status: httpStatusText.SUCCESS, data: { user: updatedUser } });
// });

// // Delete a user
// const deleteUser = asyncWrapper(async (req, res, next) => {
//   const { userId } = req.params;
//   const deletedUser = await User.findByIdAndDelete(userId);

//   if (!deletedUser) {
//     return next(appError.create("User not found", 404, httpStatusText.FAIL));
//   }

//   res.json({
//     status: httpStatusText.SUCCESS,
//     message: "User deleted successfully",
//   });
// });

module.exports = {
  getAllUsers,
  registerUser,
  loginUser,
  // getUserById,
  // updateUser,
  // deleteUser,
  getUserProfile,
  updateUserProfile,
  deleteUserProfile,
  logoutUser,
};
****************************************