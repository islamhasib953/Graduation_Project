طيب اولا عايز اتاكد من حاجةوهى ان لكل طفل ال notifivation  الخاصة بيه لان كل يوزر ممكن يكون ليه اكثر من طفل 
ثانيا عايز فايل ريدمى يشرح الموشوع وزاى استخدم حاجة زى كده
اخيرا هبتعلك كل الفلايلات اللى عندى وعدل عليها علشان نستخدم ال notifiation علشان يتم وابعت الاكواد كلها تانى من غير ما تبوظ اى حاجة فى اللوجيك علشان الاكواد كلها سليمه وشغالة

لو عايزة نضيف إشعارات لحاجات تانية (زي إن الدكتور يضيف ملاحظة في السجل الطبي بتاع الطفل، أو أي حدث تاني)،
app file
const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const bodyParser = require("body-parser");
const cookieParser = require("cookie-parser");
const dotenv = require("dotenv");
const cors = require("cors");
const morgan = require("morgan");
const limitReq = require("express-rate-limit");
const mongoSanitize = require("express-mongo-sanitize");
const xssClean = require("xss-clean");
const hpp = require("hpp");

const appError = require("./utils/appError");
const httpStatusText = require("./utils/httpStatusText");
const MQTTService = require("./services/mqtt.service");
const connectDB = require("./config/db.config");

// استيراد الـ Routes
const medicineRoutes = require("./routes/medicine.route");
const usersRoutes = require("./routes/users.route");
const childRoutes = require("./routes/child.route");
const historyRoutes = require("./routes/history.route");
const memoryRoutes = require("./routes/memory.route");
const vaccinationRoutes = require("./routes/vaccination.route");
const growthRoutes = require("./routes/growth.route");
const doctorRoutes = require("./routes/doctor.route");
const sensorDataRoutes = require("./routes/sensorData.route");
const predictionRoutes = require("./routes/predict.route");

// إعدادات أساسية
dotenv.config({ path: "./.env" });
const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: "*", // قم بتحديد نطاق التطبيق في الإنتاج
    methods: ["GET", "POST"],
  },
});

// إعدادات Express
app.use("/uploads", express.static("uploads"));
app.use(express.json());
app.use(bodyParser.json());
app.use(cookieParser());

// Middlewares
// أ. أدوات الأمان
app.use(cors());
app.use(mongoSanitize());
app.use(xssClean());
app.use(hpp());

// ب. Rate Limiting
const limiter = limitReq({
  max: 200,
  windowMs: 1000 * 60 * 60,
  message: "Too many requests, try again after one hour",
});
app.use(limiter);

// ج. Morgan لتسجيل الطلبات
app.use(morgan("combined"));

// د. Express Messages
app.use(async (req, res, next) => {
  res.locals.messages = require("express-messages")(req, res);
  next();
});

// إعداد MongoDB
connectDB();

// إعداد MQTT
const mqttService = new MQTTService(io);
mqttService.connect();

// الـ Routes
app.use("/api/users", usersRoutes);
app.use("/api/medicines", medicineRoutes);
app.use("/api/children", childRoutes);
app.use("/api/history", historyRoutes);
app.use("/api/memory", memoryRoutes);
app.use("/api/vaccinations", vaccinationRoutes);
app.use("/api/growth", growthRoutes);
app.use("/api/doctors", doctorRoutes);
app.use("/api/sensor-data", sensorDataRoutes);
app.use("/api/predictions", predictionRoutes);

// Middleware للـ Routes الغير موجودة
app.all("*", (req, res) => {
  return res.status(404).json({
    status: httpStatusText.ERROR,
    data: { message: "This resource not found" },
  });
});

// Global Error Handler
app.use((error, req, res, next) => {
  res.status(error.statusCode || 500).json({
    status: error.statusText || httpStatusText.ERROR,
    message: error.message,
    code: error.statusCode || 500,
    data: null,
  });
});

module.exports = { app, server };
*********************************************
index file


const mongoose = require("mongoose");
const { app, server } = require("./app");

process.on("uncaughtException", (err) => {
  console.error("⛔ " + err.name, err.message, err.stack);
  process.exit(1);
});

const port = process.env.PORT || 8000;

server.listen(port, () => console.log(`✅ app listening on port ${port}`));

process.on("unhandledRejection", (err) => {
  console.error("🚨 " + err.name, err.message);
  server.close(() => process.exit(1));
});
*******************************
child reoutes
const express = require("express");
const { validationResult } = require("express-validator");
const router = express.Router();

const verifyToken = require("../middlewares/virifyToken");
const checkOwnership = require("../middlewares/Ownership");
const childController = require("../controllers/child.controller");
const validationschema = require("../middlewares/validationschema");



router
  .route("/")
  // .get(verifyToken, checkOwnership, childController.getAllChildren)
  .post(
    verifyToken,
    checkOwnership,
    validationschema.validateChild,
    childController.createChild
  )
  .get(
    verifyToken,
    checkOwnership,
    validationschema.validateChild,
    childController.getChildrenForUser
  );

router
  .route("/:childId")
  .get(verifyToken, checkOwnership, childController.getSingleChild)
  .patch(
    verifyToken,
    checkOwnership,
    validationschema.validateChild,
    childController.updateChild
  )
  .delete(verifyToken, checkOwnership, childController.deleteChild);

module.exports = router;

**************************
doctor routes
const express = require("express");
const router = express.Router();

const verifyToken = require("../middlewares/virifyToken");
const allowedTo = require("../middlewares/allowedTo");
const userRoles = require("../utils/userRoles");
const doctorController = require("../controllers/doctor.controller");

// Routes للدكتور نفسه (Profile, Logout) - مش محتاج childId
router
  .route("/profile")
  .get(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
    doctorController.getDoctorProfile
  )
  .patch(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
    doctorController.updateDoctorProfile
  )
  .delete(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
    doctorController.deleteDoctorProfile
  );

router.post(
  "/logout",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
  doctorController.logoutDoctor
);

// Route لتعديل الأيام والأوقات المتاحة (جديد)
router.patch(
  "/availability",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
  doctorController.updateAvailability
);

// Route لجلب الحجوزات القادمة (ثابت)
router.get(
  "/appointments/upcoming",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
  doctorController.getUpcomingAppointments
);

// Route لجلب السجل الطبي وبيانات النمو بتاعة الطفل (ثابت، لازم يكون قبل الـ Routes الديناميكية)
router.post(
  "/child/records",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
  doctorController.getChildRecords
);

// Route لتحديث حالة الحجز (يحتوي على appointmentId)
router.patch(
  "/appointments/:appointmentId/status",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR),
  doctorController.updateAppointmentStatus
);

// Route لجلب كل الحجوزات بتاعة اليوزر مع childId في الـ Path
router.get(
  "/appointments/user/:childId",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.PATIENT),
  doctorController.getUserAppointments
);

// Route لجلب الدكاترة المفضلين مع childId في الـ Path (ثابت، لازم يكون قبل /:childId)
router.get(
  "/favorites/:childId",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.PATIENT),
  doctorController.getFavoriteDoctors
);

// Route لعرض كل الدكاترة مع childId في الـ Path (ديناميكي)
router.get(
  "/:childId",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.DOCTOR, userRoles.PATIENT),
  doctorController.getAllDoctors
);

// Routes لتفاصيل دكتور معين مع childId في الـ Path (ديناميكي)
router
  .route("/:childId/:doctorId")
  .get(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.DOCTOR, userRoles.PATIENT),
    doctorController.getSingleDoctor
  );

// Route لحجز موعد مع childId في الـ Path
router.post(
  "/:childId/:doctorId/book",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.PATIENT),
  doctorController.bookAppointment
);

// Routes لإضافة وإزالة دكتور من المفضلة مع childId في الـ Path
router
  .route("/:childId/:doctorId/favorite")
  .post(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    doctorController.addToFavorite
  )
  .delete(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    doctorController.removeFromFavorite
  );

// Routes لتعديل وإلغاء الحجز مع childId في الـ Path
router
  .route("/appointments/:childId/:appointmentId")
  .patch(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    doctorController.rescheduleAppointment
  )
  .delete(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    doctorController.deleteAppointment
  );

module.exports = router;
**************************************
user routes
const express = require("express");
const usersController = require("../controllers/users.controller");
const verifyToken = require("../middlewares/virifyToken");
const allowedTo = require("../middlewares/allowedTo");
const userRoles = require("../utils/userRoles");
const checkOwnership = require("../middlewares/Ownership");
const {
  validateRegister,
  validateLogin,
  validateUpdateUser,
} = require("../middlewares/validationschema");

const multer = require("multer");
const appError = require("../utils/appError");
const fs = require("fs");
const path = require("path");

const diskStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(__dirname, "..", "Uploads");
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const ext = file.mimetype.split("/")[1];
    cb(null, `user-${Date.now()}.${ext}`);
  },
});

const fileFilter = (req, file, cb) => {
  file.mimetype.startsWith("image")
    ? cb(null, true)
    : cb(appError.create("The file must be an image", 400), false);
};

const upload = multer({ storage: diskStorage, fileFilter });

const router = express.Router();

router
  .route("/")
  .get(verifyToken, allowedTo(userRoles.ADMIN), usersController.getAllUsers);

router
  .route("/register")
  .post(
    upload.single("avatar"),
    validateRegister,
    usersController.registerUser
  );

router.route("/login").post(validateLogin, usersController.loginUser);

router
  .route("/profile")
  .get(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    usersController.getUserProfile
  )
  .patch(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    usersController.updateUserProfile
  )
  .delete(
    verifyToken,
    allowedTo(userRoles.ADMIN, userRoles.PATIENT),
    usersController.deleteUserProfile
  );

router.post(
  "/logout",
  verifyToken,
  allowedTo(userRoles.ADMIN, userRoles.PATIENT),
  usersController.logoutUser
);

// router
//   .route("/:userId")
//   .get(verifyToken, checkOwnership, usersController.getUserById)
//   .patch(
//     verifyToken,
//     checkOwnership,
//     validateUpdateUser,
//     usersController.updateUser
//   )
//   .delete(verifyToken, checkOwnership, usersController.deleteUser);

module.exports = router;
********************************************
child model
const mongoose = require("mongoose");

const ChildSchema = new mongoose.Schema(
  {
    name: { type: String, required: [true, "Name is required"], trim: true },
    gender: {
      type: String,
      enum: ["Boy", "Girl"],
      required: [true, "Gender is required"],
    },
    birthDate: { type: Date, required: [true, "Birth date is required"] },
    heightAtBirth: { type: Number, min: [0, "Height must be positive"] },
    weightAtBirth: { type: Number, min: [0, "Weight must be positive"] },
    headCircumferenceAtBirth: {
      type: Number,
      min: [0, "Head circumference must be positive"],
    },
    bloodType: {
      type: String,
      match: [/^(A|B|AB|O)[+-]$/, "Invalid blood type"],
    },
    parentId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    deviceId: { type: String, required: false, unique: true }, // حقل جديد لتحديد الساعة
    photo: {
      type: String,
      default: "Uploads/vaccination.jpg",
      validate: {
        validator: function (value) {
          return /\.(jpg|jpeg|png|gif)$/i.test(value);
        },
        message: "Image must be a valid image file",
      },
    },
    favorite: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Doctor",
        required: false,
      },
    ], // حقل جديد لتخزين الدكاترة المفضلة لكل طفل
  },
  { timestamps: true }
);

module.exports = mongoose.model("Child", ChildSchema);
***************************************************
const mongoose = require("mongoose");
const validator = require("validator");
const userRoles = require("../utils/userRoles");

const doctorSchema = new mongoose.Schema({
  firstName: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  lastName: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  gender: {
    type: String,
    enum: ["Male", "Female"],
    required: true,
  },
  phone: {
    type: String,
    required: true,
    unique: true,
    validate: {
      validator: function (value) {
        return /^01[0-2,5]\d{8}$/.test(value);
      },
      message: "Invalid Egyptian phone number",
    },
  },
  address: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    minlength: 2,
    maxlength: 255,
    validate: [validator.isEmail, "Invalid Email"],
  },
  password: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  token: {
    type: String,
    required: false,
  },
  role: {
    type: String,
    enum: [userRoles.DOCTOR], // تحديد إن الـ role هنا للدكتور بس
    default: userRoles.DOCTOR, // التأكد إن الـ default مش معلّق
    required: true, // جعلناه إجباري
  },
  fcmToken: { type: String, default: null }, // حقل جديد
  avatar: {
    type: String,
    default: "uploads/doctor.jpg",
  },
  specialise: {
    type: String,
    required: false,
    minlength: 2,
    maxlength: 255,
    trim: true,
  },
  about: {
    type: String,
    required: false,
    minlength: 2,
    maxlength: 500,
    trim: true,
  },
  rate: {
    type: Number,
    required: false,
    min: 0,
    max: 5,
    default: 0,
  },
  availableDays: [
    {
      type: String,
      required: false,
      trim: true,
    },
  ],
  availableTimes: [
    {
      type: String,
      required: false,
      trim: true,
    },
  ],
  created_at: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model("Doctor", doctorSchema);
**********************************************************************

user model
const mongoose = require("mongoose");
const validator = require("validator");
const userRoles = require("../utils/userRoles");

const userSchema = new mongoose.Schema({
  firstName: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  lastName: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  gender: {
    type: String,
    enum: ["Male", "Female"],
    required: true,
  },
  phone: {
    type: String,
    required: true,
    unique: true,
    validate: {
      validator: function (value) {
        return /^01[0-2,5]\d{8}$/.test(value);
      },
      message: "Invalid Egyptian phone number",
    },
  },
  address: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    minlength: 2,
    maxlength: 255,
    validate: [validator.isEmail, "Invalid Email"],
  },
  password: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 255,
  },
  token: {
    type: String,
    required: false,
  },
  role: {
    type: String,
    enum: [userRoles.ADMIN, userRoles.PATIENT],
    default: userRoles.PATIENT,
    required: true,
  },
  fcmToken: { type: String, default: null }, // حقل جديد
  avatar: {
    type: String,
    default: "uploads/profile.jpg",
  },
  created_at: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model("User", userSchema);
************************************************
child cotroller
const Child = require("../models/child.model");
const User = require("../models/user.model");
const asyncWrapper = require("../middlewares/asyncWrapper");
const httpStatusText = require("../utils/httpStatusText");
const appError = require("../utils/appError");
const VaccineInfo = require("../models/vaccineInfo.model");
const UserVaccination = require("../models/UserVaccination.model");

// ✅ Create new child and assign all existing vaccinations
const createChild = asyncWrapper(async (req, res, next) => {
  const {
    name,
    gender,
    photo,
    birthDate,
    bloodType,
    heightAtBirth,
    weightAtBirth,
    headCircumferenceAtBirth,
  } = req.body;

  const parentId = req.user.id; // Get parentId from logged-in user

  if (
    !name ||
    !gender ||
    !birthDate ||
    !bloodType ||
    !heightAtBirth ||
    !weightAtBirth ||
    !headCircumferenceAtBirth
  ) {
    return next(
      appError.create("All fields are required", 400, httpStatusText.FAIL)
    );
  }

  const parent = await User.findById(parentId);
  if (!parent) {
    return next(
      appError.create("Parent does not exist", 404, httpStatusText.FAIL)
    );
  }

  const childPhoto = photo || "Uploads/child.jpg";

  // إنشاء الطفل الجديد
  const newChild = new Child({
    name,
    gender,
    photo: childPhoto,
    parentId,
    birthDate,
    bloodType,
    heightAtBirth,
    weightAtBirth,
    headCircumferenceAtBirth,
  });

  await newChild.save();

  // ✅ جلب جميع التطعيمات من قاعدة البيانات
  const allVaccines = await VaccineInfo.find();

  // ✅ إذا كان هناك تطعيمات، أضفها للطفل الجديد
  if (allVaccines.length > 0) {
    const vaccinationsToCreate = allVaccines.map((vaccine) => {
      const dueDate = new Date(birthDate);
      dueDate.setMonth(dueDate.getMonth() + vaccine.originalSchedule);

      return {
        childId: newChild._id,
        vaccineInfoId: vaccine._id,
        dueDate,
      };
    });

    await UserVaccination.insertMany(vaccinationsToCreate);
  }

  res.status(201).json({
    status: httpStatusText.SUCCESS,
    message: "Child created successfully and assigned vaccinations.",
    data: {
      child: newChild,
      parentPhone: parent.phone,
    },
  });
});

// ✅ Get all children for admin
const getAllChildren = asyncWrapper(async (req, res) => {
  const children = await Child.find({}, "_id name birthDate photo");
  res.json({
    status: httpStatusText.SUCCESS,
    data: children.map((child) => ({
      id: child._id,
      name: child.name,
      birthDate: child.birthDate,
      photo: child.photo,
    })),
  });
});

// ✅ Get all children for a specific user (logged-in user)
const getChildrenForUser = asyncWrapper(async (req, res, next) => {
  const userId = req.user.id;
  const children = await Child.find({ parentId: userId })
    .select(
      "_id name gender birthDate heightAtBirth weightAtBirth headCircumferenceAtBirth bloodType photo parentId"
    )
    .populate("parentId", "phone");

  if (!children.length) {
    return next(
      appError.create(
        "No children found for this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  res.json({
    status: httpStatusText.SUCCESS,
    data: children.map((child) => ({
      _id: child._id,
      name: child.name,
      gender: child.gender,
      birthDate: child.birthDate,
      heightAtBirth: child.heightAtBirth,
      weightAtBirth: child.weightAtBirth,
      headCircumferenceAtBirth: child.headCircumferenceAtBirth,
      bloodType: child.bloodType,
      photo: child.photo,
      parentPhone: child.parentId?.phone || null,
      parentId: child.parentId?._id || null,
    })),
  });
});

// ✅ Get single child with all details
const getSingleChild = asyncWrapper(async (req, res, next) => {
  const { childId } = req.params;

  const child = await Child.findById(childId)
    .select(
      "_id name gender birthDate heightAtBirth weightAtBirth headCircumferenceAtBirth bloodType photo parentId"
    )
    .populate("parentId", "phone");

  if (!child) {
    return next(appError.create("Child not found", 404, httpStatusText.FAIL));
  }

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      _id: child._id,
      name: child.name,
      gender: child.gender,
      birthDate: child.birthDate,
      heightAtBirth: child.heightAtBirth,
      weightAtBirth: child.weightAtBirth,
      headCircumferenceAtBirth: child.headCircumferenceAtBirth,
      bloodType: child.bloodType,
      photo: child.photo,
      parentPhone: child.parentId?.phone || null,
    },
  });
});

// ✅ Update a child
const updateChild = asyncWrapper(async (req, res, next) => {
  const { childId } = req.params;
  const {
    name,
    gender,
    birthDate,
    bloodType,
    heightAtBirth,
    weightAtBirth,
    headCircumferenceAtBirth,
    photo,
  } = req.body;

  const updatedChild = await Child.findByIdAndUpdate(
    childId,
    {
      name,
      gender,
      birthDate,
      bloodType,
      heightAtBirth,
      weightAtBirth,
      headCircumferenceAtBirth,
      photo,
    },
    { new: true }
  );

  if (!updatedChild) {
    return next(appError.create("Child not found", 404, httpStatusText.FAIL));
  }

  res.json({
    status: httpStatusText.SUCCESS,
    data: { child: updatedChild },
  });
});

// ✅ Delete a child
const deleteChild = asyncWrapper(async (req, res, next) => {
  const deletedChild = await Child.findByIdAndDelete(req.params.childId);

  if (!deletedChild) {
    return next(appError.create("Child not found", 404, httpStatusText.FAIL));
  }

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Child deleted successfully",
  });
});

module.exports = {
  createChild,
  getAllChildren,
  getChildrenForUser,
  getSingleChild,
  updateChild,
  deleteChild,
};

********************************
doctor controller
const Doctor = require("../models/doctor.model");
const User = require("../models/user.model");
const Appointment = require("../models/appointment.model");
const Child = require("../models/child.model");
const History = require("../models/history.model");
const Growth = require("../models/growth.model");
const asyncWrapper = require("../middlewares/asyncWrapper");
const httpStatusText = require("../utils/httpStatusText");
const appError = require("../utils/appError");
const userRoles = require("../utils/userRoles");
const moment = require("moment");
const mongoose = require("mongoose");

// ✅ عرض كل الدكاترة (مع childId في الـ Path)
const getAllDoctors = asyncWrapper(async (req, res, next) => {
  const { childId } = req.params;
  const userId = req.user.id;

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  const doctors = await Doctor.find().select(
    "firstName lastName phone availableTimes availableDays created_at address avatar specialise about rate"
  );

  if (!doctors.length) {
    return next(appError.create("No doctors found", 404, httpStatusText.FAIL));
  }

  const currentDay = moment().format("dddd");
  const today = moment().startOf("day").toDate();

  const doctorsWithStatus = await Promise.all(
    doctors.map(async (doctor) => {
      const hasAvailableDays =
        doctor.availableDays && doctor.availableDays.length > 0;
      const hasAvailableTimes =
        doctor.availableTimes && doctor.availableTimes.length > 0;

      if (!hasAvailableDays || !hasAvailableTimes) {
        return {
          _id: doctor._id,
          firstName: doctor.firstName,
          lastName: doctor.lastName,
          phone: doctor.phone,
          availableTimes: doctor.availableTimes,
          availableDays: doctor.availableDays,
          created_at: doctor.created_at,
          address: doctor.address,
          avatar: doctor.avatar,
          specialise: doctor.specialise,
          about: doctor.about,
          rate: doctor.rate,
          status: "Closed",
          isFavorite: child.favorite.includes(doctor._id),
        };
      }

      const isDayAvailable = doctor.availableDays.includes(currentDay);
      if (!isDayAvailable) {
        return {
          _id: doctor._id,
          firstName: doctor.firstName,
          lastName: doctor.lastName,
          phone: doctor.phone,
          availableTimes: doctor.availableTimes,
          availableDays: doctor.availableDays,
          created_at: doctor.created_at,
          address: doctor.address,
          avatar: doctor.avatar,
          specialise: doctor.specialise,
          about: doctor.about,
          rate: doctor.rate,
          status: "Closed",
          isFavorite: child.favorite.includes(doctor._id),
        };
      }

      const bookedAppointments = await Appointment.find({
        doctorId: doctor._id,
        date: today,
      }).select("time");

      const bookedTimes = bookedAppointments.map(
        (appointment) => appointment.time
      );

      const hasAvailableTimeToday = doctor.availableTimes.some(
        (time) => !bookedTimes.includes(time)
      );

      const status = hasAvailableTimeToday ? "Open" : "Closed";

      return {
        _id: doctor._id,
        firstName: doctor.firstName,
        lastName: doctor.lastName,
        phone: doctor.phone,
        availableTimes: doctor.availableTimes,
        availableDays: doctor.availableDays,
        created_at: doctor.created_at,
        address: doctor.address,
        avatar: doctor.avatar,
        specialise: doctor.specialise,
        about: doctor.about,
        rate: doctor.rate,
        status,
        isFavorite: child.favorite.includes(doctor._id),
      };
    })
  );

  res.json({
    status: httpStatusText.SUCCESS,
    data: doctorsWithStatus,
  });
});

// ✅ عرض تفاصيل دكتور معين (مع childId في الـ Path)
const getSingleDoctor = asyncWrapper(async (req, res, next) => {
  const { doctorId, childId } = req.params;
  const userId = req.user.id;

  if (
    !req.user ||
    ![userRoles.PATIENT, userRoles.DOCTOR].includes(req.user.role)
  ) {
    return next(
      appError.create(
        "Unauthorized: Only patients or doctors can view doctor details",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (req.user.role !== userRoles.DOCTOR) {
    const child = await Child.findOne({ _id: childId, parentId: userId });
    if (!child) {
      return next(
        appError.create(
          "Child not found or not associated with this user",
          404,
          httpStatusText.FAIL
        )
      );
    }
  }

  const doctor = await Doctor.findById(doctorId).select(
    "firstName lastName phone availableTimes availableDays created_at address avatar specialise about rate"
  );

  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  const currentDay = moment().format("dddd");
  const today = moment().startOf("day").toDate();

  const hasAvailableDays =
    doctor.availableDays && doctor.availableDays.length > 0;
  const hasAvailableTimes =
    doctor.availableTimes && doctor.availableTimes.length > 0;

  let status = "Closed";

  if (hasAvailableDays && hasAvailableTimes) {
    const isDayAvailable = doctor.availableDays.includes(currentDay);
    if (isDayAvailable) {
      const bookedAppointments = await Appointment.find({
        doctorId: doctor._id,
        date: today,
      }).select("time");

      const bookedTimes = bookedAppointments.map(
        (appointment) => appointment.time
      );

      const hasAvailableTimeToday = doctor.availableTimes.some(
        (time) => !bookedTimes.includes(time)
      );

      if (hasAvailableTimeToday) {
        status = "Open";
      }
    }
  }

  const bookedAppointments = await Appointment.find({
    doctorId,
    childId,
  }).select("date time");

  const child = await Child.findById(childId);

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      _id: doctor._id,
      firstName: doctor.firstName,
      lastName: doctor.lastName,
      phone: doctor.phone,
      availableTimes: doctor.availableTimes,
      availableDays: doctor.availableDays,
      created_at: doctor.created_at,
      address: doctor.address,
      avatar: doctor.avatar,
      specialise: doctor.specialise,
      about: doctor.about,
      rate: doctor.rate,
      status,
      bookedAppointments: bookedAppointments.map((appointment) => ({
        date: appointment.date,
        time: appointment.time,
      })),
      isFavorite: child ? child.favorite.includes(doctor._id) : false,
    },
  });
});


// ✅ حجز موعد مع دكتور (مع childId في الـ Path)
const bookAppointment = asyncWrapper(async (req, res, next) => {
  const { doctorId, childId } = req.params;
  const { date, time, visitType } = req.body;
  const userId = req.user.id;

  if (!date || !time || !visitType) {
    return next(
      appError.create(
        "Date, time, and visit type are required",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  const appointmentDate = moment(date);
  if (appointmentDate.isBefore(moment(), "day")) {
    return next(
      appError.create(
        "Cannot book an appointment in the past",
        400,
        httpStatusText.FAIL
      )
    );
  }

  if (!/^(1[0-2]|0?[1-9]):([0-5][0-9]) (AM|PM)$/i.test(time)) {
    return next(
      appError.create(
        "Time must be in the format HH:MM AM/PM (e.g., 9:00 AM)",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId);
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  const hasAvailableDays =
    doctor.availableDays && doctor.availableDays.length > 0;
  const hasAvailableTimes =
    doctor.availableTimes && doctor.availableTimes.length > 0;
  if (!hasAvailableDays || !hasAvailableTimes) {
    return next(
      appError.create(
        "Doctor is not available for booking",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const requestedDay = moment(date).format("dddd");
  const normalizedTime = time.trim().toUpperCase();
  const isDayAvailable = doctor.availableDays.includes(requestedDay);
  const isTimeAvailable = doctor.availableTimes.includes(normalizedTime);

  if (!isDayAvailable || !isTimeAvailable) {
    return next(
      appError.create(
        "Doctor is not available at this date or time",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const existingAppointment = await Appointment.findOne({
    doctorId,
    date: moment(date).startOf("day").toDate(),
    time: normalizedTime,
  });

  if (existingAppointment) {
    return next(
      appError.create(
        "This exact appointment (date and time) is already booked",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const newAppointment = new Appointment({
    userId,
    doctorId,
    childId,
    date: moment(date).startOf("day").toDate(),
    time: normalizedTime,
    visitType,
  });

  await newAppointment.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Appointment booked successfully",
    data: {
      appointmentId: newAppointment._id,
      doctorId: doctor._id,
      childId: newAppointment.childId,
      date: moment(newAppointment.date).format("YYYY-MM-DD"),
      time: newAppointment.time,
      visitType,
    },
  });
});

// ✅ جلب كل الحجوزات بتاعة اليوزر (مع childId في الـ Path)
const getUserAppointments = asyncWrapper(async (req, res, next) => {
  const { childId } = req.params;
  const userId = req.user.id;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can view their appointments",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  const appointments = await Appointment.find({ userId, childId })
    .populate("doctorId", "firstName lastName avatar address")
    .populate("childId", "name")
    .select("doctorId childId date time visitType status created_at");

  if (!appointments.length) {
    return next(
      appError.create("No appointments found", 404, httpStatusText.FAIL)
    );
  }

  const sortedAppointments = appointments.sort(
    (a, b) => new Date(a.date) - new Date(b.date)
  );

  const groupedAppointments = sortedAppointments.reduce((acc, appointment) => {
    const date = new Date(appointment.date);
    const monthYear = `${date.toLocaleString("default", {
      month: "short",
    })} ${date.getFullYear()}`;

    if (!acc[monthYear]) {
      acc[monthYear] = [];
    }

    acc[monthYear].push({
      appointmentId: appointment._id,
      childId: appointment.childId._id,
      childName: appointment.childId.name,
      doctorId: appointment.doctorId._id,
      doctorName: `${appointment.doctorId.firstName} ${appointment.doctorId.lastName}`,
      doctorAvatar: appointment.doctorId.avatar,
      doctorAddress: appointment.doctorId.address,
      date: appointment.date,
      time: appointment.time,
      visitType: appointment.visitType,
      status: appointment.status,
    });

    return acc;
  }, {});

  res.json({
    status: httpStatusText.SUCCESS,
    data: groupedAppointments,
  });
});

// ✅ تحديث حالة الحجز (Accept أو Close)
const updateAppointmentStatus = asyncWrapper(async (req, res, next) => {
  const { appointmentId } = req.params;
  const { status } = req.body;
  const doctorId = req.user.id;

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can update appointment status",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (!status || !["Accepted", "Closed"].includes(status)) {
    return next(
      appError.create(
        "Status must be either 'Accepted' or 'Closed'",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const appointment = await Appointment.findById(appointmentId);

  if (!appointment) {
    return next(
      appError.create("Appointment not found", 404, httpStatusText.FAIL)
    );
  }

  if (appointment.doctorId.toString() !== doctorId.toString()) {
    return next(
      appError.create(
        "You are not authorized to update this appointment",
        403,
        httpStatusText.FAIL
      )
    );
  }

  appointment.status = status;
  await appointment.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Appointment status updated successfully",
    data: {
      appointmentId: appointment._id,
      status: appointment.status,
    },
  });
});

// ✅ جلب الدكاترة المفضلين مع childId في الـ Path
const getFavoriteDoctors = asyncWrapper(async (req, res, next) => {
  const { childId } = req.params;
  const userId = req.user.id;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can view favorite doctors",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  const favoriteDoctorIds = child.favorite;
  if (!favoriteDoctorIds || favoriteDoctorIds.length === 0) {
    return next(
      appError.create("No favorite doctors found", 404, httpStatusText.FAIL)
    );
  }

  const doctors = await Doctor.find({
    _id: { $in: favoriteDoctorIds },
  }).select(
    "firstName lastName phone availableTimes availableDays created_at address avatar specialise about rate"
  );

  if (!doctors.length) {
    return next(
      appError.create("No favorite doctors found", 404, httpStatusText.FAIL)
    );
  }

  const currentDay = moment().format("dddd");
  const today = moment().startOf("day").toDate();

  const doctorsWithStatus = await Promise.all(
    doctors.map(async (doctor) => {
      const hasAvailableDays =
        doctor.availableDays && doctor.availableDays.length > 0;
      const hasAvailableTimes =
        doctor.availableTimes && doctor.availableTimes.length > 0;

      if (!hasAvailableDays || !hasAvailableTimes) {
        return {
          _id: doctor._id,
          firstName: doctor.firstName,
          lastName: doctor.lastName,
          phone: doctor.phone,
          availableTimes: doctor.availableTimes,
          availableDays: doctor.availableDays,
          created_at: doctor.created_at,
          address: doctor.address,
          avatar: doctor.avatar,
          specialise: doctor.specialise,
          about: doctor.about,
          rate: doctor.rate,
          status: "Closed",
          isFavorite: true,
        };
      }

      const isDayAvailable = doctor.availableDays.includes(currentDay);
      if (!isDayAvailable) {
        return {
          _id: doctor._id,
          firstName: doctor.firstName,
          lastName: doctor.lastName,
          phone: doctor.phone,
          availableTimes: doctor.availableTimes,
          availableDays: doctor.availableDays,
          created_at: doctor.created_at,
          address: doctor.address,
          avatar: doctor.avatar,
          specialise: doctor.specialise,
          about: doctor.about,
          rate: doctor.rate,
          status: "Closed",
          isFavorite: true,
        };
      }

      const bookedAppointments = await Appointment.find({
        doctorId: doctor._id,
        date: today,
      }).select("time");

      const bookedTimes = bookedAppointments.map(
        (appointment) => appointment.time
      );

      const hasAvailableTimeToday = doctor.availableTimes.some(
        (time) => !bookedTimes.includes(time)
      );

      const status = hasAvailableTimeToday ? "Open" : "Closed";

      return {
        _id: doctor._id,
        firstName: doctor.firstName,
        lastName: doctor.lastName,
        phone: doctor.phone,
        availableTimes: doctor.availableTimes,
        availableDays: doctor.availableDays,
        created_at: doctor.created_at,
        address: doctor.address,
        avatar: doctor.avatar,
        specialise: doctor.specialise,
        about: doctor.about,
        rate: doctor.rate,
        status,
        isFavorite: true,
      };
    })
  );

  res.json({
    status: httpStatusText.SUCCESS,
    data: doctorsWithStatus,
  });
});

// ✅ تعديل موعد الحجز (Reschedule) (مع childId في الـ Path)
const rescheduleAppointment = asyncWrapper(async (req, res, next) => {
  const { appointmentId, childId } = req.params;
  const { date, time } = req.body;
  const userId = req.user.id;

  if (!date || !time) {
    return next(
      appError.create("Date and time are required", 400, httpStatusText.FAIL)
    );
  }

  const newDate = moment(date);
  if (newDate.isBefore(moment(), "day")) {
    return next(
      appError.create(
        "Cannot reschedule to a past date",
        400,
        httpStatusText.FAIL
      )
    );
  }

  if (!/^(1[0-2]|0?[1-9]):([0-5][0-9]) (AM|PM)$/i.test(time)) {
    return next(
      appError.create(
        "Time must be in the format HH:MM AM/PM (e.g., 9:00 AM)",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const appointment = await Appointment.findById(appointmentId);

  if (!appointment) {
    return next(
      appError.create("Appointment not found", 404, httpStatusText.FAIL)
    );
  }

  if (appointment.userId.toString() !== userId.toString()) {
    return next(
      appError.create(
        "You are not authorized to reschedule this appointment",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (appointment.childId.toString() !== childId) {
    return next(
      appError.create(
        "This appointment does not belong to the specified child",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (appointment.status === "Accepted") {
    return next(
      appError.create(
        "Cannot reschedule an accepted appointment. You can only cancel it.",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(appointment.doctorId);
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  const requestedDay = newDate.format("dddd");
  const isDayAvailable = doctor.availableDays.includes(requestedDay);
  const isTimeAvailable = doctor.availableTimes.includes(time);

  if (!isDayAvailable || !isTimeAvailable) {
    return next(
      appError.create(
        "Doctor is not available at this new date or time",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const existingAppointment = await Appointment.findOne({
    doctorId: appointment.doctorId,
    date: newDate.startOf("day").toDate(),
    time,
    _id: { $ne: appointmentId },
  });

  if (existingAppointment) {
    return next(
      appError.create(
        "This exact new time slot (date and time) is already booked",
        400,
        httpStatusText.FAIL
      )
    );
  }

  appointment.date = newDate.startOf("day").toDate();
  appointment.time = time;
  await appointment.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Appointment rescheduled successfully",
    data: {
      appointmentId: appointment._id,
      childId: appointment.childId,
      date: appointment.date,
      time: appointment.time,
    },
  });
});

// ✅ إلغاء الحجز (مع childId في الـ Path)
const deleteAppointment = asyncWrapper(async (req, res, next) => {
  const { appointmentId, childId } = req.params;
  const userId = req.user.id;

  const appointment = await Appointment.findById(appointmentId);

  if (!appointment) {
    return next(
      appError.create("Appointment not found", 404, httpStatusText.FAIL)
    );
  }

  if (appointment.userId.toString() !== userId.toString()) {
    return next(
      appError.create(
        "You are not authorized to delete this appointment",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (appointment.childId.toString() !== childId) {
    return next(
      appError.create(
        "This appointment does not belong to the specified child",
        403,
        httpStatusText.FAIL
      )
    );
  }

  await Appointment.deleteOne({ _id: appointmentId });

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Appointment deleted successfully",
  });
});


// ✅ جلب كل الحجوزات القادمة للدكتور
const getUpcomingAppointments = asyncWrapper(async (req, res, next) => {
  if (!req.user || !req.user.id) {
    return next(
      appError.create(
        "Unauthorized: User ID not found in token",
        401,
        httpStatusText.FAIL
      )
    );
  }

  const doctorId = req.user.id;

  if (!mongoose.Types.ObjectId.isValid(doctorId)) {
    return next(
      appError.create("Invalid Doctor ID in token", 400, httpStatusText.FAIL)
    );
  }

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can view their upcoming appointments",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId).select(
    "firstName lastName avatar"
  );
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  const today = moment().startOf("day").toDate();

  // استخدام Aggregation Pipeline للترتيب المطلوب
  const appointments = await Appointment.aggregate([
    // الشرط الأساسي: doctorId، التاريخ من اليوم وما بعد، واستبعاد Closed
    {
      $match: {
        doctorId: new mongoose.Types.ObjectId(doctorId),
        date: { $gte: today },
        status: { $ne: "Closed" },
      },
    },
    // Populate userId و childId
    {
      $lookup: {
        from: "users",
        localField: "userId",
        foreignField: "_id",
        as: "userId",
        pipeline: [
          {
            $project: {
              firstName: 1,
              lastName: 1,
              address: 1,
            },
          },
        ],
      },
    },
    {
      $unwind: "$userId",
    },
    {
      $lookup: {
        from: "children",
        localField: "childId",
        foreignField: "_id",
        as: "childId",
      },
    },
    {
      $unwind: "$childId",
    },
    // تحويل time من صيغة 12 ساعة (مثل "8:00 PM") إلى 24 ساعة (مثل "20:00")
    {
      $addFields: {
        trimmedTime: { $trim: { input: "$time" } }, // إزالة المسافات
      },
    },
    {
      $addFields: {
        timeParts: {
          $regexMatch: {
            input: "$trimmedTime",
            regex: "^(\\d{1,2}):(\\d{2})\\s*(AM|PM)$",
            options: "i",
          },
        },
      },
    },
    {
      $addFields: {
        hour: { $toInt: { $arrayElemAt: ["$timeParts.captures", 0] } },
        minute: { $arrayElemAt: ["$timeParts.captures", 1] },
        period: { $arrayElemAt: ["$timeParts.captures", 2] },
      },
    },
    {
      $addFields: {
        hour24: {
          $cond: {
            if: { $eq: [{ $toUpper: "$period" }, "PM"] },
            then: {
              $cond: {
                if: { $eq: ["$hour", 12] },
                then: 12,
                else: { $add: ["$hour", 12] },
              },
            },
            else: {
              $cond: {
                if: { $eq: ["$hour", 12] },
                then: 0,
                else: "$hour",
              },
            },
          },
        },
      },
    },
    {
      $addFields: {
        time24: {
          $concat: [
            { $cond: { if: { $lt: ["$hour24", 10] }, then: "0", else: "" } },
            { $toString: "$hour24" },
            ":",
            { $cond: { if: { $lt: ["$minute", 10] }, then: "0", else: "" } },
            "$minute",
          ],
        },
      },
    },
    // إنشاء حقل مؤقت لتحويل date و time إلى تاريخ كامل للـ Accepted فقط
    {
      $addFields: {
        appointmentDateTime: {
          $cond: {
            if: { $eq: ["$status", "Accepted"] },
            then: {
              $dateFromString: {
                dateString: {
                  $concat: [
                    { $dateToString: { format: "%Y-%m-%d", date: "$date" } },
                    "T",
                    "$time24",
                  ],
                },
                format: "%Y-%m-%dT%H:%M",
              },
            },
            else: null, // للـ Pending، لا حاجة لـ appointmentDateTime
          },
        },
      },
    },
    // إضافة حقل sortStatus للتحكم في ترتيب Pending و Accepted
    {
      $addFields: {
        sortStatus: {
          $cond: {
            if: { $eq: ["$status", "Pending"] },
            then: 1,
            else: 2,
          },
        },
      },
    },
    // إضافة حقل sortKey للترتيب بناءً على created_at لـ Pending و appointmentDateTime لـ Accepted
    {
      $addFields: {
        sortKey: {
          $cond: {
            if: { $eq: ["$status", "Pending"] },
            then: "$created_at",
            else: "$appointmentDateTime",
          },
        },
      },
    },
    // الترتيب
    {
      $sort: {
        sortStatus: 1, // Pending (1) قبل Accepted (2)
        sortKey: 1, // Pending حسب created_at, Accepted حسب appointmentDateTime
      },
    },
    // اختيار الحقول المطلوبة
    {
      $project: {
        userId: {
          firstName: "$userId.firstName",
          lastName: "$userId.lastName",
          address: "$userId.address",
        },
        childId: {
          name: "$childId.name",
        },
        date: 1,
        time: 1,
        visitType: 1,
        status: 1,
        created_at: 1,
        _id: 1,
      },
    },
  ]);

  const upcomingCount = appointments.length;

  const upcomingAppointments = appointments.map((appointment) => {
    const appointmentData = {
      appointmentId: appointment._id,
      userName: `${appointment.userId.firstName} ${appointment.userId.lastName}`,
      childName: appointment.childId.name,
      place: appointment.visitType,
      date: moment(appointment.date).format("YYYY-MM-DD"),
      time: appointment.time,
      status:
        appointment.status === "Accepted"
          ? "ACCEPTED"
          : appointment.status === "Closed"
          ? "REFUSED"
          : "PENDING",
      created_at: moment(appointment.created_at).format("YYYY-MM-DD HH:mm:ss"),
    };

    // إضافة address لو visitType هو In-Person
    if (appointment.visitType === "In-Person") {
      appointmentData.address = appointment.userId.address;
    }

    return appointmentData;
  });

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      doctor: {
        name: `${doctor.firstName} ${doctor.lastName}`,
        avatar: doctor.avatar,
        upcomingCount: upcomingCount,
      },
      appointments: upcomingAppointments,
    },
  });
});

// ✅ جلب السجل الطبي وبيانات النمو بتاعة الطفل (بياخد childId من الـ Body)
const getChildRecords = asyncWrapper(async (req, res, next) => {
  const { childId } = req.body;
  const doctorId = req.user.id;

  if (!req.user || !req.user.id) {
    return next(
      appError.create(
        "Unauthorized: User ID not found in token",
        401,
        httpStatusText.FAIL
      )
    );
  }

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can access child records",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (!mongoose.Types.ObjectId.isValid(doctorId)) {
    return next(
      appError.create("Invalid Doctor ID in token", 400, httpStatusText.FAIL)
    );
  }

  if (!childId) {
    return next(
      appError.create(
        "Child ID is required in the body",
        400,
        httpStatusText.FAIL
      )
    );
  }

  if (!mongoose.Types.ObjectId.isValid(childId)) {
    return next(appError.create("Invalid Child ID", 400, httpStatusText.FAIL));
  }

  const child = await Child.findById(childId);
  if (!child) {
    return next(appError.create("Child not found", 404, httpStatusText.FAIL));
  }

  const medicalHistory = await History.find({ childId })
    .select(
      "diagnosis disease treatment notes date time doctorName notesImage createdAt updatedAt"
    )
    .sort({ date: -1 });

  const growthRecords = await Growth.find({ childId })
    .select(
      "weight height headCircumference date time notes notesImage ageInMonths createdAt updatedAt"
    )
    .sort({ date: -1 });

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      medicalHistory,
      growthRecords,
    },
  });
});

// ✅ جلب بيانات الدكتور (Profile)
const getDoctorProfile = asyncWrapper(async (req, res, next) => {
  const doctorId = req.user.id;

  if (!doctorId) {
    return next(
      appError.create("User ID not found in token", 401, httpStatusText.FAIL)
    );
  }

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can view their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId).select("-password -token");

  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      firstName: doctor.firstName,
      lastName: doctor.lastName,
      gender: doctor.gender,
      phone: doctor.phone,
      address: doctor.address,
      email: doctor.email,
      role: doctor.role,
      avatar: doctor.avatar,
      specialise: doctor.specialise,
      about: doctor.about,
      rate: doctor.rate,
      availableDays: doctor.availableDays,
      availableTimes: doctor.availableTimes,
      created_at: doctor.created_at,
    },
  });
});

// ✅ تعديل بيانات الدكتور (Profile)
const updateDoctorProfile = asyncWrapper(async (req, res, next) => {
  const doctorId = req.user.id;
  const {
    firstName,
    lastName,
    email,
    phone,
    address,
    specialise,
    about,
    availableDays,
    availableTimes,
  } = req.body;

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can update their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId);

  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  if (firstName) doctor.firstName = firstName;
  if (lastName) doctor.lastName = lastName;
  if (email) doctor.email = email;
  if (phone) doctor.phone = phone;
  if (address) doctor.address = address;
  if (specialise) doctor.specialise = specialise;
  if (about) doctor.about = about;
  if (availableDays) doctor.availableDays = availableDays;
  if (availableTimes) doctor.availableTimes = availableTimes;

  await doctor.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Profile updated successfully",
    data: {
      firstName: doctor.firstName,
      lastName: doctor.lastName,
      gender: doctor.gender,
      phone: doctor.phone,
      address: doctor.address,
      email: doctor.email,
      role: doctor.role,
      avatar: doctor.avatar,
      specialise: doctor.specialise,
      about: doctor.about,
      rate: doctor.rate,
      availableDays: doctor.availableDays,
      availableTimes: doctor.availableTimes,
      created_at: doctor.created_at,
    },
  });
});

// ✅ حذف الأكونت بتاع الدكتور (مع مسح الـ Token)
const deleteDoctorProfile = asyncWrapper(async (req, res, next) => {
  const doctorId = req.user.id;
  const doctorEmail = req.user.email;

  console.log("Starting deleteDoctorProfile...");
  console.log("Doctor ID from token:", doctorId);
  console.log("Doctor Email from token:", doctorEmail);

  if (!doctorId) {
    console.log("No doctorId found in token");
    return next(
      appError.create("User ID not found in token", 401, httpStatusText.FAIL)
    );
  }

  if (!mongoose.Types.ObjectId.isValid(doctorId)) {
    console.log("Invalid doctorId format:", doctorId);
    return next(
      appError.create("Invalid Doctor ID in token", 400, httpStatusText.FAIL)
    );
  }

  if (req.user.role !== userRoles.DOCTOR) {
    console.log("User is not a doctor, role:", req.user.role);
    return next(
      appError.create(
        "Unauthorized: Only doctors can delete their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  // التأكد من الاتصال بقاعدة البيانات
  console.log("Checking database connection...");
  const dbConnection = mongoose.connection;
  if (dbConnection.readyState !== 1) {
    console.log(
      "Database connection is not ready, state:",
      dbConnection.readyState
    );
    return next(
      appError.create("Database connection error", 500, httpStatusText.ERROR)
    );
  }
  console.log("Database connection is ready");

  const doctor = await Doctor.findById(doctorId);
  if (!doctor) {
    console.log("Doctor not found in database with ID:", doctorId);
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  console.log("Doctor found:", doctor.email);

  if (doctor.email !== doctorEmail) {
    console.log(
      "Email mismatch! Token email:",
      doctorEmail,
      "Doctor email:",
      doctor.email
    );
    return next(
      appError.create("Unauthorized: Email mismatch", 403, httpStatusText.FAIL)
    );
  }

  // استخدام Transaction للتأكد من إن كل العمليات بتتم مع بعض
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    console.log("Clearing doctor token...");
    doctor.token = null;
    await doctor.save({ session });
    console.log("Token cleared successfully");

    console.log("Deleting appointments for doctorId:", doctorId);
    const appointmentDeleteResult = await Appointment.deleteMany(
      { doctorId },
      { session }
    );
    console.log(
      "Appointments deleted:",
      appointmentDeleteResult.deletedCount,
      "appointments"
    );

    console.log("Deleting doctor with ID:", doctorId);
    const deleteResult = await Doctor.deleteOne({ _id: doctorId }, { session });
    if (deleteResult.deletedCount === 0) {
      console.log("Failed to delete doctor: No doctor found during deletion");
      throw new Error("Failed to delete doctor account");
    }

    const doctorAfterDelete = await Doctor.findById(doctorId).session(session);
    if (doctorAfterDelete) {
      console.log("Doctor still exists after deletion:", doctorAfterDelete);
      throw new Error("Doctor account was not deleted from the database");
    }

    console.log("Doctor deleted successfully");

    console.log("Removing doctor from favorites...");
    const favoriteUpdateResult = await Child.updateMany(
      { favorite: doctorId },
      { $pull: { favorite: doctorId } },
      { session }
    );
    console.log(
      "Favorites updated, modified documents:",
      favoriteUpdateResult.modifiedCount
    );

    // حذف الدكتور من جدول User (لو موجود)
    console.log("Deleting doctor from User collection...");
    const userDeleteResult = await User.deleteOne(
      { email: doctorEmail },
      { session }
    );
    console.log(
      "User deleted from User collection:",
      userDeleteResult.deletedCount,
      "users"
    );

    // Commit الـ Transaction
    await session.commitTransaction();
    console.log("Transaction committed successfully");

    res.json({
      status: httpStatusText.SUCCESS,
      message:
        "Doctor account, appointments, favorites, and user entry deleted successfully",
    });
  } catch (error) {
    // Rollback الـ Transaction لو حصل أي خطأ
    await session.abortTransaction();
    console.log("Transaction aborted due to error:", error.message);
    return next(
      appError.create(
        error.message || "Failed to delete doctor account",
        500,
        httpStatusText.ERROR
      )
    );
  } finally {
    session.endSession();
  }
});

// ✅ تسجيل الخروج للدكتور
const logoutDoctor = asyncWrapper(async (req, res, next) => {
  const doctorId = req.user.id;

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can logout",
        403,
        httpStatusText.FAIL
      )
    );
  }

  // البحث عن الدكتور
  const doctor = await Doctor.findById(doctorId);
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  // حذف الـ token
  doctor.token = null;
  await doctor.save();

  // الرد بنجاح
  res.json({
    status: httpStatusText.SUCCESS,
    message: "Logged out successfully",
  });
});

// ✅ إضافة دكتور للمفضلة (مع childId في الـ Path)
const addToFavorite = asyncWrapper(async (req, res, next) => {
  const { doctorId, childId } = req.params;
  const userId = req.user.id;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can add doctors to favorites",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId);
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  if (child.favorite.includes(doctorId)) {
    return next(
      appError.create("Doctor already in favorites", 400, httpStatusText.FAIL)
    );
  }

  child.favorite.push(doctorId);
  await child.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Doctor added to favorites successfully",
  });
});

// ✅ إزالة دكتور من المفضلة (مع childId في الـ Path)
const removeFromFavorite = asyncWrapper(async (req, res, next) => {
  const { doctorId, childId } = req.params;
  const userId = req.user.id;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can remove doctors from favorites",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const child = await Child.findOne({ _id: childId, parentId: userId });
  if (!child) {
    return next(
      appError.create(
        "Child not found or not associated with this user",
        404,
        httpStatusText.FAIL
      )
    );
  }

  if (!child.favorite.includes(doctorId)) {
    return next(
      appError.create("Doctor not found in favorites", 400, httpStatusText.FAIL)
    );
  }

  child.favorite = child.favorite.filter(
    (favId) => favId.toString() !== doctorId
  );
  await child.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Doctor removed from favorites successfully",
  });
});

// ✅ تعديل الأيام والأوقات المتاحة للدكتور
const updateAvailability = asyncWrapper(async (req, res, next) => {
  const doctorId = req.user.id;
  const { availableDays, availableTimes } = req.body;

  if (req.user.role !== userRoles.DOCTOR) {
    return next(
      appError.create(
        "Unauthorized: Only doctors can update their availability",
        403,
        httpStatusText.FAIL
      )
    );
  }

  if (!availableDays && !availableTimes) {
    return next(
      appError.create(
        "At least one of availableDays or availableTimes is required",
        400,
        httpStatusText.FAIL
      )
    );
  }

  const doctor = await Doctor.findById(doctorId);
  if (!doctor) {
    return next(appError.create("Doctor not found", 404, httpStatusText.FAIL));
  }

  // التحقق من الأيام
  const validDays = [
    "Saturday",
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
  ];
  if (availableDays) {
    if (!Array.isArray(availableDays)) {
      return next(
        appError.create(
          "availableDays must be an array",
          400,
          httpStatusText.FAIL
        )
      );
    }
    // التحقق من إن مفيش أيام فاضية أو مكررة
    const trimmedDays = availableDays.map((day) => day.trim());
    const uniqueDays = [...new Set(trimmedDays)];
    const invalidDays = uniqueDays.filter(
      (day) => !validDays.includes(day) || day === ""
    );
    if (invalidDays.length > 0) {
      return next(
        appError.create(
          `Invalid days: ${invalidDays.join(
            ", "
          )}. Days must be one of: ${validDays.join(", ")}`,
          400,
          httpStatusText.FAIL
        )
      );
    }
    doctor.availableDays = uniqueDays;
  }

  // التحقق من الأوقات
  if (availableTimes) {
    if (!Array.isArray(availableTimes)) {
      return next(
        appError.create(
          "availableTimes must be an array",
          400,
          httpStatusText.FAIL
        )
      );
    }
    const timeFormatRegex = /^(1[0-2]|0?[1-9]):([0-5][0-9]) (AM|PM)$/i;
    // التحقق من إن مفيش أوقات فاضية أو مكررة
    const trimmedTimes = availableTimes.map((time) =>
      time.trim().toUpperCase()
    );
    const uniqueTimes = [...new Set(trimmedTimes)];
    const invalidTimes = uniqueTimes.filter(
      (time) => !timeFormatRegex.test(time) || time === ""
    );
    if (invalidTimes.length > 0) {
      return next(
        appError.create(
          `Invalid times: ${invalidTimes.join(
            ", "
          )}. Times must be in the format HH:MM AM/PM (e.g., 9:00 AM)`,
          400,
          httpStatusText.FAIL
        )
      );
    }
    doctor.availableTimes = uniqueTimes;
  }

  await doctor.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Availability updated successfully",
    data: {
      availableDays: doctor.availableDays,
      availableTimes: doctor.availableTimes,
    },
  });
});

module.exports = {
  getAllDoctors,
  getSingleDoctor,
  bookAppointment,
  getUserAppointments,
  updateAppointmentStatus,
  rescheduleAppointment,
  deleteAppointment,
  getUpcomingAppointments,
  getDoctorProfile,//
  updateDoctorProfile,//
  deleteDoctorProfile,//
  logoutDoctor,//
  addToFavorite,
  removeFromFavorite,
  getFavoriteDoctors,
  getChildRecords,
  updateAvailability,
};
**********************************************
user controllers
const asyncWrapper = require("../middlewares/asyncWrapper");
const User = require("../models/user.model");
const Doctor = require("../models/doctor.model");
const httpStatusText = require("../utils/httpStatusText");
const appError = require("../utils/appError");
const bcrypt = require("bcryptjs");
const genrateJWT = require("../utils/genrate.JWT");
const userRoles = require("../utils/userRoles");
const mongoose = require("mongoose");

// Get all users
const getAllUsers = asyncWrapper(async (req, res) => {
  const users = await User.find({}, { __v: 0, password: false });
  res.json({ status: httpStatusText.SUCCESS, data: { users } });
});


// // Get a single user by ID
// const getUserById = asyncWrapper(async (req, res, next) => {
//   const { userId } = req.params;

//   const user = await User.findById(userId);

//   if (!user) {
//     return next(appError.create("User not found", 404, httpStatusText.FAIL));
//   }

//   res.json({ status: httpStatusText.SUCCESS, data: { user } });
// });

// ✅ جلب بيانات اليوزر (Profile)
const getUserProfile = asyncWrapper(async (req, res, next) => {
  const userId = req.user.id;

  if (!userId) {
    return next(
      appError.create("User ID not found in token", 401, httpStatusText.FAIL)
    );
  }

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can view their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const user = await User.findById(userId).select("-password -token");

  if (!user) {
    return next(appError.create("User not found", 404, httpStatusText.FAIL));
  }

  res.json({
    status: httpStatusText.SUCCESS,
    data: {
      firstName: user.firstName,
      lastName: user.lastName,
      gender: user.gender,
      phone: user.phone,
      address: user.address,
      email: user.email,
      role: user.role,
      avatar: user.avatar,
      favorite: user.favorite,
      created_at: user.created_at,
    },
  });
});

// ✅ تعديل بيانات اليوزر (Profile)
const updateUserProfile = asyncWrapper(async (req, res, next) => {
  const userId = req.user.id;
  const { firstName, lastName, email, phone, address } = req.body;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can update their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const user = await User.findById(userId);

  if (!user) {
    return next(appError.create("User not found", 404, httpStatusText.FAIL));
  }

  if (firstName) user.firstName = firstName;
  if (lastName) user.lastName = lastName;
  if (email) user.email = email;
  if (phone) user.phone = phone;
  if (address) user.address = address;

  await user.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Profile updated successfully",
    data: {
      firstName: user.firstName,
      lastName: user.lastName,
      gender: user.gender,
      phone: user.phone,
      address: user.address,
      email: user.email,
      role: user.role,
      avatar: user.avatar,
      favorite: user.favorite,
      created_at: user.created_at,
    },
  });
});

// ✅ حذف الأكونت بتاع اليوزر (مع مسح الـ Token)
const deleteUserProfile = asyncWrapper(async (req, res, next) => {
  const userId = req.user.id;
  const userEmail = req.user.email;

  if (!userId) {
    return next(
      appError.create("User ID not found in token", 401, httpStatusText.FAIL)
    );
  }

  if (!mongoose.Types.ObjectId.isValid(userId)) {
    return next(
      appError.create("Invalid User ID in token", 400, httpStatusText.FAIL)
    );
  }

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can delete their profile",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const user = await User.findById(userId);
  if (!user) {
    return next(appError.create("User not found", 404, httpStatusText.FAIL));
  }

  if (user.email !== userEmail) {
    return next(
      appError.create("Unauthorized: Email mismatch", 403, httpStatusText.FAIL)
    );
  }

  // استخدام Transaction للتأكد من إن كل العمليات بتتم مع بعض
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    user.token = null;
    await user.save({ session });

    const deleteResult = await User.deleteOne({ _id: userId }, { session });
    if (deleteResult.deletedCount === 0) {
      throw new Error("Failed to delete user account");
    }

    // Commit الـ Transaction
    await session.commitTransaction();

    res.json({
      status: httpStatusText.SUCCESS,
      message: "User account deleted successfully",
    });
  } catch (error) {
    // Rollback الـ Transaction لو حصل أي خطأ
    await session.abortTransaction();
    return next(
      appError.create(
        error.message || "Failed to delete user account",
        500,
        httpStatusText.ERROR
      )
    );
  } finally {
    session.endSession();
  }
});

// ✅ تسجيل الخروج لليوزر
const logoutUser = asyncWrapper(async (req, res, next) => {
  const userId = req.user.id;

  if (req.user.role !== userRoles.PATIENT) {
    return next(
      appError.create(
        "Unauthorized: Only patients can logout",
        403,
        httpStatusText.FAIL
      )
    );
  }

  const user = await User.findById(userId);
  if (!user) {
    return next(appError.create("User not found", 404, httpStatusText.FAIL));
  }

  user.token = null;
  await user.save();

  res.json({
    status: httpStatusText.SUCCESS,
    message: "Logged out successfully",
  });
});

// Register New User or Doctor
const registerUser = asyncWrapper(async (req, res, next) => {
  const {
    firstName,
    lastName,
    gender,
    phone,
    address,
    email,
    password,
    role,
    specialise,
    about,
    rate,
    availableDays,
    availableTimes,
  } = req.body;

  const oldUser = await User.findOne({ email });
  const oldDoctor = await Doctor.findOne({ email });
  if (oldUser || oldDoctor) {
    const error = appError.create(
      "Email already exists",
      400,
      httpStatusText.FAIL
    );
    return next(error);
  }

  const hashedPassword = await bcrypt.hash(password, 12);

  if (role === userRoles.DOCTOR) {
    const newDoctor = new Doctor({
      firstName,
      lastName,
      gender,
      phone,
      address,
      email,
      password: hashedPassword,
      role: userRoles.DOCTOR,
      specialise,
      about,
      rate,
      availableDays,
      availableTimes,
      avatar: req.file ? req.file.filename : "uploads/doctor.jpg",
    });

    const token = await genrateJWT(
      {
        email: newDoctor.email,
        id: newDoctor._id,
        role: newDoctor.role,
      },
      "7d"
    );
    newDoctor.token = token;

    await newDoctor.save();

    const doctorData = {
      _id: newDoctor._id,
      firstName: newDoctor.firstName,
      lastName: newDoctor.lastName,
      gender: newDoctor.gender,
      phone: newDoctor.phone,
      address: newDoctor.address,
      email: newDoctor.email,
      role: newDoctor.role,
      specialise: newDoctor.specialise,
      about: newDoctor.about,
      rate: newDoctor.rate,
      availableDays: newDoctor.availableDays,
      availableTimes: newDoctor.availableTimes,
      avatar: newDoctor.avatar,
      created_at: newDoctor.created_at,
      token: newDoctor.token,
    };

    res.status(201).json({
      status: httpStatusText.SUCCESS,
      message: "Doctor registered successfully",
      data: { user: doctorData },
    });
  } else {
    const newUser = new User({
      firstName,
      lastName,
      gender,
      phone,
      address,
      email,
      password: hashedPassword,
      role: userRoles.PATIENT,
      avatar: req.file ? req.file.filename : "uploads/profile.jpg",
    });

    const token = await genrateJWT(
      {
        email: newUser.email,
        id: newUser._id,
        role: newUser.role,
      },
      "7d"
    );
    newUser.token = token;

    await newUser.save();

    const userData = {
      _id: newUser._id,
      firstName: newUser.firstName,
      lastName: newUser.lastName,
      gender: newUser.gender,
      phone: newUser.phone,
      address: newUser.address,
      email: newUser.email,
      role: newUser.role,
      avatar: newUser.avatar,
      favorite: newUser.favorite,
      created_at: newUser.created_at,
      token: newUser.token,
    };

    res.status(201).json({
      status: httpStatusText.SUCCESS,
      message: "User registered successfully",
      data: { user: userData },
    });
  }
});

// Login User or Doctor
const loginUser = asyncWrapper(async (req, res, next) => {
  const { email, password } = req.body;
  if (!email || !password) {
    const error = appError.create(
      "Email and Password are required",
      400,
      httpStatusText.FAIL
    );
    return next(error);
  }

  let user = await User.findOne({ email });
  let role;

  if (user) {
    role = user.role;
  } else {
    user = await Doctor.findOne({ email });
    if (user) {
      role = user.role;
    }
  }

  if (!user) {
    const error = appError.create("User not found", 400, httpStatusText.FAIL);
    return next(error);
  }

  const isPasswordCorrect = await bcrypt.compare(password, user.password);
  if (isPasswordCorrect && user) {
    const token = await genrateJWT(
      {
        email: user.email,
        id: user._id,
        role: role,
      },
      "7d"
    );

    res.status(200).json({
      status: httpStatusText.SUCCESS,
      data: {
        token: token,
        role: role,
      },
    });
  } else {
    const error = appError.create(
      "Email or Password are incorrect",
      500,
      httpStatusText.ERROR
    );
    return next(error);
  }
});

// Update user details
// const updateUser = asyncWrapper(async (req, res, next) => {
//   const { userId } = req.params;
//   const { firstName, lastName, gender, phone, address, password, avatar } =
//     req.body;

//   let updateData = { firstName, lastName, gender, phone, address };

//   if (password) {
//     const hashedPassword = await bcrypt.hash(password, 12);
//     updateData.password = hashedPassword;
//   }

//   if (req.file) {
//     updateData.avatar = req.file.filename;
//   }

//   const updatedUser = await User.findByIdAndUpdate(userId, updateData, {
//     new: true,
//   });

//   if (!updatedUser) {
//     return next(appError.create("User not found", 404, httpStatusText.FAIL));
//   }

//   res.json({ status: httpStatusText.SUCCESS, data: { user: updatedUser } });
// });

// // Delete a user
// const deleteUser = asyncWrapper(async (req, res, next) => {
//   const { userId } = req.params;
//   const deletedUser = await User.findByIdAndDelete(userId);

//   if (!deletedUser) {
//     return next(appError.create("User not found", 404, httpStatusText.FAIL));
//   }

//   res.json({
//     status: httpStatusText.SUCCESS,
//     message: "User deleted successfully",
//   });
// });

module.exports = {
  getAllUsers,
  registerUser,
  loginUser,
  // getUserById,
  // updateUser,
  // deleteUser,
  getUserProfile,
  updateUserProfile,
  deleteUserProfile,
  logoutUser,
};
****************************************